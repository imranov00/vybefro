import AsyncStorage from '@react-native-async-storage/async-storage';
import axios from 'axios';
import { ZodiacSign } from '../types/zodiac';
import { getRefreshToken, getToken, removeAllTokens, saveRefreshToken, saveToken } from '../utils/tokenStorage';

// CLOUDFLARE TUNNEL URL'i - deƒüi≈üebilir
const CLOUDFLARE_URL = 'https://placement-hottest-eagle-drunk.trycloudflare.com';

// Alternative endpoints (gerektiƒüinde eklenebilir)
const FALLBACK_URLS: string[] = [
  // Buraya alternatif URL'ler eklenebilir
  // 'https://your-backend.herokuapp.com',
  // 'https://api.yourdomain.com',
];

// Aktif API URL
let API_URL = CLOUDFLARE_URL;

// WebSocket URL'i (API URL'inden t√ºretilir)
export const getWebSocketUrl = (): string => {
  const baseUrl = API_URL.replace('https://', 'wss://').replace('http://', 'ws://');
  console.log('üîó [API] WebSocket URL olu≈üturuldu:', baseUrl, 'API URL:', API_URL);
  return baseUrl;
};

console.log('üîó [API CONFIG] Base URL:', API_URL);

// Network durumunu kontrol eden fonksiyon
const checkNetworkHealth = async (url: string): Promise<boolean> => {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 saniye timeout
    
    const response = await fetch(`${url}/health`, { 
      method: 'GET',
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return response.ok;
  } catch (error) {
    console.warn(`[NETWORK CHECK] ${url} eri≈üilemez:`, error);
    return false;
  }
};

// En iyi URL'i bulan fonksiyon
const findBestApiUrl = async (): Promise<string> => {
  // √ñnce ana URL'i dene
  const mainUrlWorks = await checkNetworkHealth(CLOUDFLARE_URL);
  if (mainUrlWorks) {
    return CLOUDFLARE_URL;
  }

  // Fallback URL'leri dene
  for (const fallbackUrl of FALLBACK_URLS) {
    const works = await checkNetworkHealth(fallbackUrl);
    if (works) {
      console.log(`[API FAILOVER] ${fallbackUrl} kullanƒ±lƒ±yor`);
      return fallbackUrl;
    }
  }

  // Hi√ßbiri √ßalƒ±≈ümƒ±yorsa ana URL'i d√∂nd√ºr (hata mesajƒ± i√ßin)
  console.error('[API FAILOVER] Hi√ßbir endpoint eri≈üilebilir deƒüil');
  return CLOUDFLARE_URL;
};

// API isteƒüi i√ßin bir axios √∂rneƒüi olu≈üturuluyor
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 3000, // 3 saniye timeout (√ßok agresif)
});

// Dynamic base URL g√ºncelleme
const updateApiBaseUrl = async () => {
  const bestUrl = await findBestApiUrl();
  if (bestUrl !== API_URL) {
    API_URL = bestUrl;
    api.defaults.baseURL = bestUrl;
    console.log(`[API UPDATE] Base URL g√ºncellendi: ${bestUrl}`);
  }
};

// ƒ∞stek/yanƒ±t durumlarƒ±nƒ± kontrol eden interceptor'lar
api.interceptors.request.use(
  async (config) => {
    // config undefined kontrol√º ekle
    if (!config) {
      console.error('‚ùå [API] Request interceptor hatasƒ±: config undefined');
      return Promise.reject(new Error('API config undefined'));
    }
    
    console.log(`[API REQUEST] ${config.method?.toUpperCase()} ${config.url}`);
    
    // Token gerekli olmayan endpoint'ler veya refresh token istekleri
    const noAuthEndpoints = ['/health', '/api/auth/login', '/api/auth/register', '/api/auth/register-music'];
    const isNoAuthEndpoint = noAuthEndpoints.some(endpoint => config.url?.includes(endpoint)) ||
                            (config as any).metadata?.isRefreshRequest === true ||
                            config.url?.includes('/api/auth/refresh') ||
                            config.url?.includes('/api/auth/persistent-login');
    
    if (!isNoAuthEndpoint) {
      // Token'ƒ± al ve kontrol et
      const token = await getToken();
      const refreshToken = await getRefreshToken();
      
      console.log('üîë [API] Token kontrol√º:', {
        hasAccessToken: !!token,
        hasRefreshToken: !!refreshToken
      });
      
      if (token) {
        // Token'ƒ± decode et ve s√ºresi dolmu≈ü mu kontrol et
        try {
          const payload = JSON.parse(atob(token.split('.')[1]));
          const currentTime = Date.now() / 1000;
          
          console.log('üîç [API] Token i√ßeriƒüi:', {
            exp: payload.exp ? new Date(payload.exp * 1000).toISOString() : 'N/A',
            iat: payload.iat ? new Date(payload.iat * 1000).toISOString() : 'N/A',
            userId: payload.userId,
            username: payload.username
          });
          
          // Token s√ºresi dolmu≈ü mu kontrol et
          if (payload.exp && payload.exp < currentTime) {
            console.warn('‚ö†Ô∏è [API] Token s√ºresi dolmu≈ü!');
            
            // √áok fazla yenileme denemesi yapƒ±lmƒ±≈üsa logout yap
            if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
              console.error('‚ùå [API] Maksimum token yenileme denemesi a≈üƒ±ldƒ±, logout yapƒ±lƒ±yor');
              refreshAttempts = 0;
              await removeAllTokens();
              await AsyncStorage.setItem('logout_alert_needed', 'true');
              return Promise.reject(new Error('Oturum s√ºresi dolmu≈ü. L√ºtfen tekrar giri≈ü yapƒ±n.'));
            }
            
            // Refresh token varsa yenilemeyi dene - kontroll√º ≈üekilde
            if (refreshToken && !isRefreshing) {
              refreshAttempts++;
              isRefreshing = true;
              
              console.log(`üîÑ [API] Token yenileniyor... (${refreshAttempts}/${MAX_REFRESH_ATTEMPTS})`);
              
              try {
                // Kontroll√º refresh token isteƒüi - response interceptor'da i≈ülenecek
                const refreshResponse = await api.post('/api/auth/refresh', { refreshToken }, {
                  timeout: 5000,
                  // √ñzel metadata ekle ki response interceptor'da tanƒ±sƒ±n
                  metadata: { isRefreshRequest: true }
                } as any);
                
                if (refreshResponse.data?.token) {
                  await saveToken(refreshResponse.data.token);
                  
                  if (refreshResponse.data?.refreshToken) {
                    await saveRefreshToken(refreshResponse.data.refreshToken);
                  }
                  
                  // Yeni token ile devam et
                  config.headers['Authorization'] = `Bearer ${refreshResponse.data.token}`;
                  refreshAttempts = 0; // Ba≈üarƒ±lƒ± yenileme, counter'ƒ± sƒ±fƒ±rla
                  console.log('‚úÖ [API] Token ba≈üarƒ±yla yenilendi');
                } else {
                  throw new Error('Token yenileme yanƒ±tƒ± ge√ßersiz');
                }
              } catch (refreshError) {
                console.error('‚ùå [API] Token yenileme hatasƒ±:', refreshError);
                
                // Token yenilenemiyorsa t√ºm token'larƒ± temizle ve logout flag'i set et
                await removeAllTokens();
                await AsyncStorage.setItem('logout_alert_needed', 'true');
                
                return Promise.reject(new Error('Oturum s√ºresi dolmu≈ü. L√ºtfen tekrar giri≈ü yapƒ±n.'));
              } finally {
                isRefreshing = false;
              }
            } else {
              console.warn('‚ö†Ô∏è [API] Refresh token yok veya zaten yenileniyor, logout yapƒ±lƒ±yor');
              
              // Refresh token yoksa veya zaten yenileniyorsa logout yap
              await removeAllTokens();
              await AsyncStorage.setItem('logout_alert_needed', 'true');
              
              return Promise.reject(new Error('Oturum s√ºresi dolmu≈ü. L√ºtfen tekrar giri≈ü yapƒ±n.'));
            }
          } else {
            // Token ge√ßerli, header'a ekle
            config.headers['Authorization'] = `Bearer ${token}`;
          }
        } catch (tokenParseError) {
          console.error('‚ùå [API] Token parse hatasƒ±:', tokenParseError);
          
          // Token parse edilemiyorsa temizle
          await removeAllTokens();
          await AsyncStorage.setItem('logout_alert_needed', 'true');
          
          return Promise.reject(new Error('Ge√ßersiz token. L√ºtfen tekrar giri≈ü yapƒ±n.'));
        }
      } else {
        console.warn('‚ö†Ô∏è [API] Token bulunamadƒ±');
        
        // Token yoksa logout yap
        await removeAllTokens();
        await AsyncStorage.setItem('logout_alert_needed', 'true');
        
        return Promise.reject(new Error('Oturum bulunamadƒ±. L√ºtfen giri≈ü yapƒ±n.'));
      }
    }
    
    return config;
  },
  (error) => {
    console.error('[API REQUEST ERROR]', error);
    return Promise.reject(error);
  }
);

// Token yenileme i≈ülemi i√ßin global flag (d√∂ng√ºy√º engellemek i√ßin)
let isRefreshing = false;
let failedQueue: Array<{ resolve: (value: any) => void; reject: (reason?: any) => void }> = [];
let refreshAttempts = 0;
const MAX_REFRESH_ATTEMPTS = 3; // Biraz daha fazla deneme hakkƒ±

// Otomatik token yenileme i√ßin timer
let autoRefreshTimer: ReturnType<typeof setInterval> | null = null;
let lastTokenRefreshTime = 0;
const TOKEN_REFRESH_INTERVAL = 15 * 60 * 1000; // 15 dakika

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(({ resolve, reject }) => {
    if (error) {
      reject(error);
    } else {
      resolve(token);
    }
  });
  
  failedQueue = [];
};

// Otomatik token yenileme fonksiyonu
const startAutoTokenRefresh = () => {
  // Eƒüer zaten bir timer varsa temizle
  if (autoRefreshTimer) {
    clearInterval(autoRefreshTimer);
  }
  
  console.log('üîÑ [API] Otomatik token yenileme ba≈ülatƒ±ldƒ± (15 dakika aralƒ±klarla)');
  
  autoRefreshTimer = setInterval(async () => {
    try {
      const refreshToken = await getRefreshToken();
      const accessToken = await getToken();
      
      // Her iki token da varsa yenileme yap
      if (refreshToken && accessToken) {
        console.log('üîÑ [API] Otomatik token yenileme ba≈ülƒ±yor...');
        
        // Token'ƒ±n s√ºresi dolmu≈ü mu kontrol et
        try {
          const payload = JSON.parse(atob(accessToken.split('.')[1]));
          const currentTime = Date.now() / 1000;
          
          // Token'ƒ±n s√ºresi 5 dakika i√ßinde dolacaksa yenile
          if (payload.exp && (payload.exp - currentTime) < 300) {
            console.log('‚è∞ [API] Token s√ºresi yakƒ±nda dolacak, yenileniyor...');
            await authApi.refreshToken();
            lastTokenRefreshTime = Date.now();
            console.log('‚úÖ [API] Otomatik token yenileme ba≈üarƒ±lƒ±');
          } else {
            console.log('‚úÖ [API] Token hen√ºz ge√ßerli, yenileme gerekmiyor');
          }
        } catch (tokenError) {
          console.error('‚ùå [API] Token parse hatasƒ±:', tokenError);
          // Token parse edilemiyorsa yenilemeyi dene
          await authApi.refreshToken();
          lastTokenRefreshTime = Date.now();
        }
      } else {
        console.log('‚ö†Ô∏è [API] Token bulunamadƒ±, otomatik yenileme durduruluyor');
        stopAutoTokenRefresh();
      }
    } catch (error) {
      console.error('‚ùå [API] Otomatik token yenileme hatasƒ±:', error);
      // Hata durumunda timer'ƒ± durdur
      stopAutoTokenRefresh();
    }
  }, TOKEN_REFRESH_INTERVAL);
};

// Otomatik token yenilemeyi durdur
const stopAutoTokenRefresh = () => {
  if (autoRefreshTimer) {
    clearInterval(autoRefreshTimer);
    autoRefreshTimer = null;
    console.log('üõë [API] Otomatik token yenileme durduruldu');
  }
};

// Token refresh i≈ülemi i√ßin yardƒ±mcƒ± fonksiyon
const performTokenRefresh = async (refreshToken: string): Promise<{ token: string; refreshToken?: string }> => {
  try {
    console.log('üîÑ [API] Token yenileme ba≈ülƒ±yor...');
    
    const response = await api.post('/api/auth/refresh', { refreshToken }, {
      timeout: 10000, // 10 saniye timeout
      metadata: { isRefreshRequest: true }
    } as any);
    
    if (response.data?.token) {
      console.log('‚úÖ [API] Token ba≈üarƒ±yla yenilendi');
      return {
        token: response.data.token,
        refreshToken: response.data.refreshToken
      };
    } else {
      throw new Error('Token yenileme yanƒ±tƒ± ge√ßersiz');
    }
  } catch (error) {
    console.error('‚ùå [API] Token yenileme hatasƒ±:', error);
    throw error;
  }
};

api.interceptors.response.use(
  async (response) => {
    console.log(`[API RESPONSE] ${response.status} ${response.config.url}`);
    
    // Response header'larƒ±nda yeni token kontrol√º
    const newToken = response.headers['x-new-token'];
    const tokenRefreshed = response.headers['x-token-refreshed'];
    
    if (newToken && tokenRefreshed === 'true') {
      console.log('üîÑ [API] Token otomatik yenilendi (response header)');
      
      // Yeni token'ƒ± kaydet
      await saveToken(newToken);
      
      // Opsiyonel: Kullanƒ±cƒ±ya bildirim (kaldƒ±rabilirsiniz)
      // console.log('‚úÖ [API] Token yenilendi');
    }
    
    return response;
  },
  async (error) => {
    const originalRequest = error.config;
    
    // originalRequest undefined kontrol√º ekle
    if (!originalRequest) {
      console.error('‚ùå [API] Response interceptor hatasƒ±: originalRequest undefined');
      return Promise.reject(error);
    }
    
    // Refresh token isteƒüi ise d√∂ng√ºye girmesin - direkt hata fƒ±rlat
    if (originalRequest.metadata?.isRefreshRequest || originalRequest.url?.includes('/api/auth/refresh')) {
      console.error('‚ùå [API] Refresh token isteƒüi ba≈üarƒ±sƒ±z:', error.response?.status);
      return Promise.reject(error);
    }
    
    // 401 hatasƒ± ve hen√ºz retry yapƒ±lmamƒ±≈üsa (403 swipe limit hatasƒ± deƒüil)
    if (error.response?.status === 401 && !originalRequest._retry) {
      if (isRefreshing) {
        // Zaten yenileme yapƒ±lƒ±yorsa, kuyruƒüa ekle
        return new Promise((resolve, reject) => {
          failedQueue.push({ resolve, reject });
        }).then(token => {
          if (token) {
            originalRequest.headers['Authorization'] = `Bearer ${token}`;
            return api(originalRequest);
          }
          return Promise.reject(error);
        }).catch(err => {
          return Promise.reject(err);
        });
      }

      originalRequest._retry = true;
      isRefreshing = true;

      try {
        console.log('üîÑ [API] 401 hatasƒ± - Token yenileniyor...');
        const refreshToken = await getRefreshToken();
        
        if (!refreshToken) {
          throw new Error('Oturum s√ºresi dolmu≈ü');
        }
        
        // Yardƒ±mcƒ± fonksiyonu kullan
        const refreshResult = await performTokenRefresh(refreshToken);
        
        // Yeni token'larƒ± kaydet
        await saveToken(refreshResult.token);
        
        if (refreshResult.refreshToken) {
          await saveRefreshToken(refreshResult.refreshToken);
        }
        
        // Ba≈üarƒ±lƒ± kuyruƒüu i≈üle
        processQueue(null, refreshResult.token);
        
        // Orijinal isteƒüi yeni token ile tekrar yap
        originalRequest.headers['Authorization'] = `Bearer ${refreshResult.token}`;
        console.log('‚úÖ [API] Token yenilendi, istek tekrarlanƒ±yor');
        return api(originalRequest);
        
      } catch (refreshError) {
        console.error('‚ùå [API] Token yenileme hatasƒ±:', refreshError);
        
        // Refresh token ge√ßersizse t√ºm token'larƒ± temizle
        await removeAllTokens();
        
        // Ba≈üarƒ±sƒ±z kuyruƒüu i≈üle
        processQueue(refreshError, null);
        
        // Logout alert flag'i set et
        try {
          await AsyncStorage.setItem('logout_alert_needed', 'true');
          console.log('üö® [API] Logout alert flag set edildi');
        } catch (error) {
          console.error('‚ùå [API] Logout alert flag set hatasƒ±:', error);
        }
        
        return Promise.reject(refreshError);
      } finally {
        isRefreshing = false;
      }
    }
    
    // Diƒüer hatalar i√ßin mevcut logic
    if (error.response) {
      console.error(`[API RESPONSE ERROR] ${error.response.status}`, error.response.data);
      
      // 401/403 hatalarƒ±nda anƒ±nda logout tetikle
      if (error.response.status === 401 || error.response.status === 403) {
        console.log('üîí [API] Yetkilendirme hatasƒ± - logout tetikleniyor');
        try {
          await AsyncStorage.setItem('logout_alert_needed', 'true');
          console.log('üö® [API] Logout alert flag set edildi');
          
          // T√ºm token'larƒ± hemen temizle
          await removeAllTokens();
          console.log('üóëÔ∏è [API] T√ºm token\'lar temizlendi');
        } catch (alertError) {
          console.error('‚ùå [API] Logout alert flag set hatasƒ±:', alertError);
        }
      }
    } else if (error.request) {
      console.error('[API REQUEST FAILED]', error.request);
      
      // Network hatasƒ± varsa, URL'i yeniden kontrol et
      if (error.code === 'NETWORK_ERROR' || error.message.includes('Network Error')) {
        console.log('[API RETRY] Network hatasƒ±, alternative URL deneniyor...');
        await updateApiBaseUrl();
      }
    } else {
      console.error('[API ERROR]', error.message);
    }
    
    // 403 SWIPE_LIMIT_EXCEEDED i√ßin √∂zel hata y√∂netimi
    if (error.response?.status === 403 && error.response?.data?.code === 'SWIPE_LIMIT_EXCEEDED') {
      console.warn('‚ö†Ô∏è [API] Swipe limit doldu - Token silinmeyecek');
      
      // Swipe limit hatasƒ± i√ßin √∂zel error objesi
      const swipeLimitError = new Error('Swipe limiti doldu') as any;
      swipeLimitError.isSwipeLimitError = true;
      swipeLimitError.swipeLimitInfo = error.response?.data?.swipeLimitInfo;
      swipeLimitError.premiumInfo = error.response?.data?.premiumInfo;
      swipeLimitError.message = error.response?.data?.message || 'G√ºnl√ºk swipe limitiniz dolmu≈ü';
      
      return Promise.reject(swipeLimitError);
    }
    
    return Promise.reject(error);
  }
);

// Backend response formatƒ±nƒ± normalize eden fonksiyon
const normalizeDiscoverResponse = (
  backendResponse: any, 
  refresh: boolean, 
  showLikedMe: boolean, 
  page: number, 
  limit: number
): DiscoverResponse => {
  console.log('üîÑ [API] Response normalizasyonu ba≈ülƒ±yor:', {
    hasUser: !!backendResponse.user,
    hasUsers: !!backendResponse.users,
    userKeys: Object.keys(backendResponse.user || {}),
    responseKeys: Object.keys(backendResponse)
  });

  // Backend'den gelen response formatƒ±nƒ± kontrol et
  if (backendResponse.hasOwnProperty('user') && !backendResponse.users) {
    // Kullanƒ±cƒ± null ise (kullanƒ±cƒ± bulunamadƒ±)
    if (!backendResponse.user) {
      console.log('üì≠ [API] Kullanƒ±cƒ± bulunamadƒ± (user: null)');
      return {
        success: backendResponse.success || false,
        users: [],
        totalCount: 0,
        returnedCount: 0,
        message: backendResponse.message || 'Kullanƒ±cƒ± bulunamadƒ±',
        hasMore: backendResponse.hasMoreUsers || false,
        hasMoreUsers: backendResponse.hasMoreUsers || false,
        cooldownInfo: backendResponse.cooldownInfo ? {
          canRefresh: true,
          nextRefreshTime: new Date(Date.now() + (backendResponse.cooldownInfo.likeCooldownMinutes || 10) * 60 * 1000).toISOString(),
          remainingSeconds: (backendResponse.cooldownInfo.likeCooldownMinutes || 10) * 60,
          message: `Yenileme i√ßin ${backendResponse.cooldownInfo.likeCooldownMinutes || 10} dakika bekleyin`,
          likeCooldownMinutes: backendResponse.cooldownInfo.likeCooldownMinutes,
          dislikeCooldownMinutes: backendResponse.cooldownInfo.dislikeCooldownMinutes,
          isPremiumCooldown: backendResponse.cooldownInfo.isPremiumCooldown
        } : undefined,
        swipeLimitInfo: backendResponse.swipeLimitInfo ? {
          isPremium: backendResponse.swipeLimitInfo.isPremium || false,
          remainingSwipes: backendResponse.swipeLimitInfo.remainingSwipes || 0,
          dailySwipeCount: backendResponse.swipeLimitInfo.dailySwipeCount || 0,
          canSwipe: backendResponse.swipeLimitInfo.canSwipe || false,
          nextResetTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
          resetMessage: 'G√ºnl√ºk swipe limiti yarƒ±n sƒ±fƒ±rlanacak',
          isLimitReached: (backendResponse.swipeLimitInfo.remainingSwipes || 0) <= 0,
          limitMessage: (backendResponse.swipeLimitInfo.remainingSwipes || 0) <= 0 
            ? 'G√ºnl√ºk swipe limitiniz doldu! Premium √ºyelik ile sƒ±nƒ±rsƒ±z swipe yapabilirsiniz.' 
            : `${backendResponse.swipeLimitInfo.remainingSwipes || 0} swipe hakkƒ±nƒ±z kaldƒ±`,
          premiumInfo: backendResponse.premiumInfo
        } : undefined
      };
    }
    
    // Yeni backend formatƒ±: tek kullanƒ±cƒ± objesi
    const normalizedUser: DiscoverUser = {
      id: backendResponse.user.id,
      username: backendResponse.user.username,
      firstName: backendResponse.user.firstName,
      lastName: backendResponse.user.lastName,
      fullName: backendResponse.user.fullName,
      birthDate: backendResponse.user.birthDate,
      age: backendResponse.user.age,
      gender: backendResponse.user.gender,
      bio: backendResponse.user.bio,
      zodiacSign: backendResponse.user.zodiacSign,
      isPremium: backendResponse.user.isPremium,
      lastActiveTime: backendResponse.user.lastActiveTime,
      location: backendResponse.user.location,
      isVerified: backendResponse.user.isVerified,
      profileImageUrl: backendResponse.user.profileImageUrl,
      photos: backendResponse.user.photos || [],
      photoCount: backendResponse.user.photoCount || 0,
      // Yeni backend sistemi i√ßin ek alanlar
      compatibilityScore: backendResponse.user.compatibilityScore,
      compatibilityMessage: backendResponse.user.compatibilityMessage,
      distanceKm: backendResponse.user.distanceKm,
      activityStatus: backendResponse.user.activityStatus,
      lastSeen: backendResponse.user.lastActiveTime,
      isOnline: backendResponse.user.activityStatus === 'online'
    };

    console.log('‚úÖ [API] Kullanƒ±cƒ± normalize edildi:', {
      id: normalizedUser.id,
      name: normalizedUser.fullName,
      compatibilityScore: normalizedUser.compatibilityScore,
      hasPhotos: normalizedUser.photos?.length > 0
    });

    return {
      success: backendResponse.success,
      users: [normalizedUser],
      totalCount: backendResponse.totalRemainingUsers || 1,
      returnedCount: 1,
      message: 'Kullanƒ±cƒ± ba≈üarƒ±yla getirildi',
      hasMore: backendResponse.hasMoreUsers || false,
      cooldownInfo: {
        canRefresh: !refresh, // Refresh yapƒ±lmƒ±≈üsa tekrar yapƒ±lamaz
        nextRefreshTime: new Date(Date.now() + (backendResponse.cooldownInfo?.likeCooldownMinutes || 10) * 60 * 1000).toISOString(),
        remainingSeconds: (backendResponse.cooldownInfo?.likeCooldownMinutes || 10) * 60,
        message: `Yenileme i√ßin ${backendResponse.cooldownInfo?.likeCooldownMinutes || 10} dakika bekleyin`
      },
      swipeLimitInfo: {
        isPremium: backendResponse.swipeLimitInfo?.isPremium || false,
        remainingSwipes: backendResponse.swipeLimitInfo?.remainingSwipes || 0,
        dailySwipeCount: 0, // Backend'den gelmiyorsa 0
        canSwipe: (backendResponse.swipeLimitInfo?.remainingSwipes || 0) > 0,
        nextResetTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 saat sonra
        resetMessage: 'G√ºnl√ºk swipe limiti yarƒ±n sƒ±fƒ±rlanacak',
        // Swipe limit kontrol√º i√ßin ek alanlar
        isLimitReached: (backendResponse.swipeLimitInfo?.remainingSwipes || 0) <= 0,
        limitMessage: (backendResponse.swipeLimitInfo?.remainingSwipes || 0) <= 0 
          ? 'G√ºnl√ºk swipe limitiniz doldu! Premium √ºyelik ile sƒ±nƒ±rsƒ±z swipe yapabilirsiniz.' 
          : `${backendResponse.swipeLimitInfo?.remainingSwipes || 0} swipe hakkƒ±nƒ±z kaldƒ±`,
        // Premium bilgileri
        premiumInfo: backendResponse.premiumInfo
      }
    };
  } else if (backendResponse.users) {
    // Eski format: users array'i
    return backendResponse;
  } else {
    // Hi√ß kullanƒ±cƒ± yok
    console.warn('‚ö†Ô∏è [API] Backend response formatƒ± tanƒ±nmadƒ±:', backendResponse);
    return {
      success: backendResponse.success || false,
      users: [],
      totalCount: 0,
      returnedCount: 0,
      message: 'Kullanƒ±cƒ± bulunamadƒ±',
      hasMore: false
    };
  }
};

// Mock data i√ßin fallback fonksiyonlarƒ±
const createMockUserProfile = (): UserProfileResponse => ({
  id: 1,
  username: 'demo_user',
  email: 'demo@example.com',
  firstName: 'Demo',
  lastName: 'User',
  birthDate: '1995-06-15',
  gender: 'MALE',
  zodiacSign: ZodiacSign.GEMINI,
  zodiacSignTurkish: 'ƒ∞kizler',
  zodiacSignEmoji: '‚ôä',
  zodiacSignDisplayName: '‚ôä ƒ∞kizler',
  profileImageUrl: null,
  bio: 'Demo kullanƒ±cƒ± profili - Backend baƒülantƒ±sƒ± kuruluyor...'
});

// Mock DiscoverResponse i√ßin fallback fonksiyon
const createMockDiscoverResponse = (): DiscoverResponse => ({
  success: true,
  users: [
    {
      id: 123,
      username: 'johndoe',
      firstName: 'John',
      lastName: 'Doe',
      fullName: 'John Doe',
      birthDate: '1995-05-15T00:00:00',
      age: 28,
      gender: 'MALE',
      bio: 'Merhaba! Ben John, yeni insanlarla tanƒ±≈ümayƒ± seviyorum.',
      zodiacSign: 'TAURUS',
      isPremium: false,
      lastActiveTime: '2024-01-15T14:30:00',
      location: 'ƒ∞stanbul, T√ºrkiye',
      isVerified: true,
      profileImageUrl: 'https://example.com/photos/profile123.jpg',
      photos: [
        {
          id: 456,
          imageUrl: 'https://example.com/photos/photo1.jpg',
          isProfilePhoto: true,
          displayOrder: 1
        }
      ],
      photoCount: 1
    }
  ],
  totalCount: 1,
  returnedCount: 1,
  message: 'Mock data ba≈üarƒ±yla getirildi'
});

// API i√ßin veri t√ºrleri
export interface RegisterRequest {
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  birthDate: string;
  password: string;
  gender: 'MALE' | 'FEMALE' | 'OTHER';
}

export interface RegisterMusicRequest {
  username: string;
  email: string;
  password: string;
  firstName: string;
  lastName: string;
  birthDate: string;
  gender: string;
}

export interface ConfirmZodiacRequest {
  userId: number;
  zodiacSign: ZodiacSign | string;
}

export interface LoginRequest {
  usernameOrEmail: string;
  password: string;
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface RefreshTokenResponse {
  token: string;
  refreshToken: string;
}

export interface LoginResponse {
  token: string;
  refreshToken: string;
  user: UserProfileResponse;
  success?: boolean; // Persistent login i√ßin
}

export interface UserProfileResponse {
  id: number;
  username: string;
  email: string;
  firstName: string;
  lastName: string;
  birthDate: string;
  gender: string;
  zodiacSign: ZodiacSign | string;
  zodiacSignTurkish?: string;
  zodiacSignEmoji?: string;
  zodiacSignDisplayName?: string;
  profileImageUrl: string | null;
  bio: string | null;
  isPremium?: boolean; // Premium durumu
}

export interface AccountUpdateRequest {
  firstName?: string;
  lastName?: string;
  username?: string;
  email?: string;
  bio?: string;
}

export interface PhotoResponse {
  id: number;
  url: string;
  publicId: string;
  uploadedAt: string;
  isProfilePhoto: boolean;
  displayOrder: number;
  description?: string | null;
}

export interface PhotoOrderRequest {
  photoIds: string[];
}

export interface PhotoDescriptionRequest {
  description: string;
}

// Premium i≈ülemleri i√ßin interface'ler
export interface PremiumFeature {
  id: string;
  title: string;
  description: string;
  icon: string;
}

export interface PremiumStatus {
  isPremium: boolean;
  premiumExpiresAt: string | null;
  premiumFeatures: {
    unlimitedSwipes: boolean;
    seeWhoLikedYou: boolean;
    advancedFilters: boolean;
    priorityMatching: boolean;
  };
  remainingSwipes?: number;
  totalSwipes?: number;
  nextResetTime?: string;
}

export interface PremiumStatusResponse {
  success: boolean;
  data: PremiumStatus;
}

export interface PremiumPurchaseRequest {
  plan: 'monthly' | 'yearly';
  paymentMethod: string;
}

export interface PremiumPurchaseResponse {
  success: boolean;
  message: string;
  premiumUntil: string;
}

export interface PremiumCancelResponse {
  success: boolean;
  message: string;
}

// Beƒüeni i≈ülemleri i√ßin interface'ler
export interface UserWhoLikedMe {
  id: string;
  firstName: string;
  lastName: string;
  fullName?: string;
  age: number;
  profileImageUrl: string;
  zodiacSign: string;
  compatibilityScore: number;
  lastActiveTime?: string;
  location?: string;
}

export interface UsersWhoLikedMeResponse {
  success: boolean;
  users: UserWhoLikedMe[];
  totalCount: number;
  hasMore: boolean;
  currentPage: number;
  limit: number;
  message?: string;
}

// √áƒ±kƒ±≈ü isteƒüi i√ßin interface
export interface LogoutResponse {
  success: boolean;
  message: string;
}

// Swipe ve Match API'leri i√ßin interface'ler
export interface PotentialMatch {
  id: number;
  username: string;
  firstName: string;
  lastName: string;
  age: number;
  profileImageUrl: string | null;
  photos: string[];
  bio: string | null;
  zodiacSign: ZodiacSign | string;
  compatibilityScore: number;
  compatibilityDescription: string;
  compatibilityMessage?: string;
  distance?: number;
  isOnline?: boolean;
  lastSeen?: string;
}

export interface SwipeRequest {
  toUserId?: number;      // Backend'de beklenen alan
  targetUserId?: string;  // Eski sistem i√ßin (opsiyonel)
  action: 'LIKE' | 'DISLIKE';
  // Geriye uyumluluk i√ßin
  userId?: number;        // toUserId ile aynƒ± ama√ß
}

export interface SwipeResponse {
  success: boolean;
  isMatch: boolean;
  status: 'LIKED' | 'DISLIKED' | 'MATCHED';
  matchId?: number;
  remainingSwipes?: number;
  message: string;
  // Eski sistem i√ßin
  resetInfo?: {
    nextResetTime: string;
    hoursUntilReset: number;
    minutesUntilReset: number;
    secondsUntilReset: number;
    totalSecondsUntilReset: number;
    resetMessage: string;
  };
  // Yeni backend sistemi i√ßin
  swipeLimitInfo?: {
    isPremium: boolean;
    remainingSwipes: number;
    dailySwipeCount: number;
    canSwipe: boolean;
    nextResetTime: string;
    resetMessage: string;
  };
  cooldownInfo?: {
    canRefresh: boolean;
    nextRefreshTime: string;
    remainingSeconds: number;
    message: string;
  };
}

export interface Match {
  id: number;
  matchedUser: {
    id: number;
    username: string;
    firstName: string;
    lastName: string;
    age: number;
    profileImageUrl: string | null;
    zodiacSign: ZodiacSign | string;
  };
  compatibilityScore: number;
  compatibilityDescription: string;
  matchType: 'ZODIAC' | 'MUSIC' | 'GENERAL';
  matchedAt: string;
  lastMessageAt?: string;
  unreadCount?: number;
}

export interface HighCompatibilityMatchesResponse {
  matches: Match[];
  totalCount: number;
}

export interface PotentialMatchesResponse {
  users: PotentialMatch[];
  totalCount: number;
  hasMore: boolean;
}

export interface PhotoItem {
  id: number;
  imageUrl: string;
  isPrimary: boolean;
  uploadDate: string;
}

export interface UserActivity {
  activityType: string;
  description: string;
  timestamp: string;
}

export interface SwipeLimitInfo {
  isPremium: boolean;
  remainingSwipes: number;
  dailySwipeCount: number;
  canSwipe: boolean;
  // Backend'den gelen ek alanlar
  backwardCompatibility?: boolean;
  // Swipe limit kontrol√º i√ßin ek alanlar
  isLimitReached?: boolean;
  limitMessage?: string;
  // Reset bilgileri
  nextResetTime?: string;
  resetMessage?: string;
  // Premium bilgileri
  premiumInfo?: {
    benefits: string[];
    isPremium: boolean;
    premiumPrice: number;
  };
}

export interface DiscoverUser {
  id: number;
  username: string;
  firstName: string;
  lastName: string;
  fullName: string;
  birthDate: string;
  age: number;
  gender: string;
  bio: string;
  zodiacSign: string;
  isPremium: boolean;
  lastActiveTime: string;
  location: string;
  isVerified: boolean;
  profileImageUrl: string;
  photos: Array<{
    id: number;
    imageUrl: string;
    photoUrl?: string; // Backward compatibility i√ßin
    isProfilePhoto: boolean;
    displayOrder: number;
  }>;
  photoCount: number;
  // Yeni backend sistemi i√ßin ek alanlar
  compatibilityScore?: number;        // Bur√ß uyumluluk skoru
  compatibilityMessage?: string;      // Uyumluluk mesajƒ±
  distanceKm?: number;               // Mesafe (km)
  activityStatus?: 'online' | 'offline' | 'recently'; // Aktiflik durumu
  lastSeen?: string;                 // Son g√∂r√ºlme zamanƒ±
  isOnline?: boolean;                // √áevrimi√ßi mi?
  // Cooldown ve swipe status bilgileri
  cooldownInfo?: {
    isExpired: boolean;
    remainingMessage: string;
  };
  swipeStatus?: 'NONE' | 'LIKE' | 'DISLIKE' | 'MATCH';
}

export interface DiscoverResponse {
  success: boolean;
  users: DiscoverUser[];  // Kullanƒ±cƒ± array'i
  totalCount: number;
  returnedCount: number;
  message: string;
  hasMore?: boolean; // Yeni backend sistemi i√ßin
  hasMoreUsers?: boolean; // Kullanƒ±cƒ± bitti mi kontrol√º
  cooldownInfo?: {   // Cooldown bilgisi
    canRefresh: boolean;
    nextRefreshTime: string;
    remainingSeconds: number;
    message: string;
    // Backend'den gelen ek alanlar
    likeCooldownMinutes?: number;
    dislikeCooldownMinutes?: number;
    isPremiumCooldown?: boolean;
    matchExpiryHours?: number;
  };
  swipeLimitInfo?: { // Swipe limit bilgisi
    isPremium: boolean;
    remainingSwipes: number;
    dailySwipeCount: number;
    canSwipe: boolean;
    nextResetTime: string;
    resetMessage: string;
    // Backend'den gelen ek alanlar
    backwardCompatibility?: boolean;
    // Swipe limit kontrol√º i√ßin ek alanlar
    isLimitReached?: boolean;
    limitMessage?: string;
    // Premium bilgileri
    premiumInfo?: {
      benefits: string[];
      isPremium: boolean;
      premiumPrice: number;
    };
  };
}

// JWT token'ƒ±nƒ± decode etmek i√ßin basit fonksiyon (debug ama√ßlƒ±)
const decodeJWT = (token: string) => {
  try {
    const base64Url = token.split('.')[1];
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch (error) {
    console.error('‚ùå [API] Token decode hatasƒ±:', error);
    return null;
  }
};

// API'yi kullanƒ±rken gerekli token header'larƒ±nƒ± olu≈üturur
const createAuthHeader = async () => {
  try {
    const token = await getToken();
    const refreshToken = await getRefreshToken();
    
    console.log('üîë [API] Token kontrol√º:', {
      hasAccessToken: !!token,
      hasRefreshToken: !!refreshToken
    });
    
    if (!token) {
      console.warn('‚ö†Ô∏è [API] Token bulunamadƒ± - Kullanƒ±cƒ± giri≈ü yapmamƒ±≈ü olabilir');
      throw new Error('Token bulunamadƒ± - L√ºtfen giri≈ü yapƒ±n');
    }
    
    // Token i√ßeriƒüini debug et
    const decodedToken = decodeJWT(token);
    if (decodedToken) {
      console.log('üîç [API] Token i√ßeriƒüi:', {
        userId: decodedToken.userId || decodedToken.sub || decodedToken.id,
        username: decodedToken.username,
        exp: decodedToken.exp ? new Date(decodedToken.exp * 1000).toISOString() : 'N/A',
        iat: decodedToken.iat ? new Date(decodedToken.iat * 1000).toISOString() : 'N/A'
      });
      
      // Token s√ºresi dolmu≈ü mu kontrol et
      if (decodedToken.exp && decodedToken.exp * 1000 < Date.now()) {
        console.warn('‚ö†Ô∏è [API] Token s√ºresi dolmu≈ü!');
      }
    }
    
    const headers: Record<string, string> = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    };
    
    // Refresh token varsa X-Refresh-Token header'ƒ±nƒ± ekle
    if (refreshToken) {
      headers['X-Refresh-Token'] = refreshToken;
    }
    
    return { headers };
  } catch (error) {
    console.error('‚ùå [API] Token olu≈üturma hatasƒ±:', error);
    throw error;
  }
};

// Kullanƒ±cƒ± i≈ülemleri i√ßin API
export const authApi = {
  // Bur√ß modunda kayƒ±t ol
  async register(data: RegisterRequest): Promise<any> {
    return api.post('/api/auth/register', data);
  },
  
  // M√ºzik modunda kayƒ±t ol
  async registerMusic(data: RegisterMusicRequest): Promise<any> {
    return api.post('/api/auth/register-music', data);
  },
  
  // Bur√ß onaylama
  async confirmZodiac(data: ConfirmZodiacRequest): Promise<any> {
    return api.post(`/api/users/${data.userId}/zodiac-confirmation`, { 
      zodiacSign: data.zodiacSign 
    });
  },
  
  // Giri≈ü yapma
  async login(data: LoginRequest): Promise<LoginResponse> {
    const response = await api.post('/api/auth/login', data);
    
    // JWT token ve refresh token varsa saklama i≈ülemi 
    if (response.data?.token) {
      await saveToken(response.data.token);
      console.log('‚úÖ [API] Login - access token kaydedildi');
    }
    
    if (response.data?.refreshToken) {
      await saveRefreshToken(response.data.refreshToken);
      console.log('‚úÖ [API] Login - refresh token kaydedildi');
    }
    
    // Otomatik token yenilemeyi ba≈ülat
    startAutoTokenRefresh();
    lastTokenRefreshTime = Date.now();
    
    return response.data;
  },
  
  // Token yenileme
  async refreshToken(): Promise<RefreshTokenResponse> {
    try {
      const refreshToken = await getRefreshToken();
      
      if (!refreshToken) {
        throw new Error('Oturum s√ºresi dolmu≈ü');
      }
      
      console.log('üîÑ [API] Token yenileme ba≈ülƒ±yor...');
      
      const response = await api.post('/api/auth/refresh', { refreshToken }, {
        timeout: 10000, // 10 saniye timeout
        metadata: { isRefreshRequest: true }
      } as any);
      
      // Yeni token'larƒ± kaydet
      if (response.data?.token) {
        await saveToken(response.data.token);
        console.log('‚úÖ [API] Yeni access token kaydedildi');
      }
      
      if (response.data?.refreshToken) {
        await saveRefreshToken(response.data.refreshToken);
        console.log('‚úÖ [API] Yeni refresh token kaydedildi');
      }
      
      // Son yenileme zamanƒ±nƒ± g√ºncelle
      lastTokenRefreshTime = Date.now();
      
      console.log('üîÑ [API] Token ba≈üarƒ±yla yenilendi');
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] Token yenileme hatasƒ±:', error);
      
      // Refresh token ge√ßersizse t√ºm token'larƒ± temizle
      await removeAllTokens();
      
      // Logout alert flag'i set et
      try {
        await AsyncStorage.setItem('logout_alert_needed', 'true');
        console.log('üö® [API] Logout alert flag set edildi');
      } catch (alertError) {
        console.error('‚ùå [API] Logout alert flag set hatasƒ±:', alertError);
      }
      
      throw error;
    }
  },
  
  // Otomatik giri≈ü yapma (persistent login)
  async persistentLogin(): Promise<LoginResponse> {
    try {
      const refreshToken = await getRefreshToken();
      
      if (!refreshToken) {
        throw new Error('Oturum s√ºresi dolmu≈ü');
      }
      
      console.log('üîÑ [API] Persistent login deneniyor...');
      
      // Daha hƒ±zlƒ± timeout i√ßin √∂zel config
      const response = await api.post('/api/auth/persistent-login', {
        refreshToken: refreshToken
      }, {
        timeout: 8000, // 8 saniye timeout
        metadata: { isRefreshRequest: true }
      } as any);
      
      if (response.data?.success && response.data?.token) {
        // Yeni token'ƒ± kaydet
        await saveToken(response.data.token);
        console.log('‚úÖ [API] Persistent login - access token kaydedildi');
        
        // Refresh token da varsa g√ºncelle
        if (response.data?.refreshToken) {
          await saveRefreshToken(response.data.refreshToken);
          console.log('‚úÖ [API] Persistent login - refresh token g√ºncellendi');
        }
        
        // Otomatik token yenilemeyi ba≈ülat
        startAutoTokenRefresh();
        lastTokenRefreshTime = Date.now();
        
        console.log('‚úÖ [API] Persistent login ba≈üarƒ±lƒ± - otomatik yenileme ba≈ülatƒ±ldƒ±');
        return response.data;
      }
      
      throw new Error('Persistent login ba≈üarƒ±sƒ±z');
    } catch (error: any) {
      console.log('‚ùå [API] Persistent login hatasƒ±:', error.message);
      
      // Ge√ßersiz refresh token'ƒ± temizle
      await removeAllTokens();
      
      // Logout alert flag'i set et
      try {
        await AsyncStorage.setItem('logout_alert_needed', 'true');
        console.log('üö® [API] Persistent login ba≈üarƒ±sƒ±z - logout alert flag set edildi');
      } catch (alertError) {
        console.error('‚ùå [API] Logout alert flag set hatasƒ±:', alertError);
      }
      
      throw error;
    }
  },

  // √áƒ±kƒ±≈ü yapma
  logout: async (): Promise<LogoutResponse> => {
    try {
      const response = await api.post('/api/auth/logout');
      
      // Otomatik token yenilemeyi durdur
      stopAutoTokenRefresh();
      
      // √áƒ±kƒ±≈ü sonrasƒ± t√ºm token'larƒ± temizle
      await removeAllTokens();
      
      console.log('‚úÖ [API] Logout ba≈üarƒ±lƒ± - otomatik yenileme durduruldu');
      
      return response.data;
    } catch (error) {
      // Hata olsa bile otomatik yenilemeyi durdur ve token'larƒ± temizle
      stopAutoTokenRefresh();
      await removeAllTokens();
      throw error;
    }
  }
};

// Kullanƒ±cƒ± profili i≈ülemleri i√ßin API
export const userApi = {
  // Kullanƒ±cƒ± kendi profilini getirme
  async getProfile(): Promise<UserProfileResponse> {
    const authHeader = await createAuthHeader();
    const response = await api.get('/api/users/profile', authHeader);
    return response.data;
  },
  
  // Belirli bir kullanƒ±cƒ±nƒ±n profilini getirme
  async getUserProfile(userId: number): Promise<UserProfileResponse> {
    const authHeader = await createAuthHeader();
    const response = await api.get(`/api/users/profile/${userId}`, authHeader);
    return response.data;
  },
  
  // Hesap bilgilerini g√ºncelleme
  async updateAccount(data: AccountUpdateRequest): Promise<UserProfileResponse> {
    const authHeader = await createAuthHeader();
    const response = await api.put('/api/users/account', data, authHeader);
    return response.data;
  },
  
  // Profil fotoƒürafƒ± y√ºkleme
  async uploadProfileImage(imageFile: FormData): Promise<any> {
    const token = await getToken();
    if (!token) {
      throw new Error('Oturum a√ßƒ±k deƒüil');
    }
    
    const response = await api.post('/api/users/profile/image', imageFile, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'multipart/form-data'
      }
    });
    return response.data;
  },
  
  // Profil fotoƒürafƒ±nƒ± silme
  async deleteProfileImage(): Promise<any> {
    const authHeader = await createAuthHeader();
    const response = await api.delete('/api/users/profile/image', authHeader);
    return response.data;
  },
  
  // Kullanƒ±cƒ± fotoƒüraflarƒ±nƒ± listeleme
  async getPhotos(): Promise<PhotoResponse[]> {
    const authHeader = await createAuthHeader();
    const response = await api.get('/api/images/list', authHeader);
    return response.data.photos;
  },
  
  // Belirli bir kullanƒ±cƒ±nƒ±n fotoƒüraflarƒ±nƒ± listeleme
  async getUserPhotos(userId: number): Promise<PhotoResponse[]> {
    const authHeader = await createAuthHeader();
    const response = await api.get(`/api/images/user/${userId}`, authHeader);
    return response.data.photos;
  },
  
  // Yeni fotoƒüraf y√ºkleme
  async uploadPhoto(photoFile: FormData): Promise<PhotoResponse> {
    const token = await getToken();
    if (!token) {
      throw new Error('Oturum a√ßƒ±k deƒüil');
    }
    
    const response = await api.post('/api/images/upload', photoFile, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'multipart/form-data'
      }
    });
    return response.data;
  },
  
  // Fotoƒüraf silme
  async deletePhoto(publicId: string): Promise<{ success: boolean; message: string }> {
    try {
      if (!publicId) {
        throw new Error('Fotoƒüraf ID\'si gereklidir');
      }

      const authHeader = await createAuthHeader();
      const response = await api.delete(`/api/images/delete/${publicId}`, authHeader);
      
      return {
        success: true,
        message: 'Fotoƒüraf ba≈üarƒ±yla silindi'
      };
    } catch (error: any) {
      if (error.response) {
        throw new Error(error.response.data.message || 'Fotoƒüraf silinirken bir hata olu≈ütu');
      } else if (error.request) {
        throw new Error('Sunucuya ula≈üƒ±lamƒ±yor');
      } else {
        throw new Error(error.message || 'Beklenmeyen bir hata olu≈ütu');
      }
    }
  },
  
  // Fotoƒürafƒ± profil fotoƒürafƒ± olarak ayarlama
  async setAsProfilePhoto(photoId: number): Promise<any> {
    const authHeader = await createAuthHeader();
    const response = await api.post(`/api/images/set-profile-photo/${photoId}`, {}, authHeader);
    return response.data;
  },
  
  // Fotoƒüraflarƒ±n sƒ±rasƒ±nƒ± g√ºncelleme
  async updatePhotoOrder(data: PhotoOrderRequest): Promise<any> {
    const authHeader = await createAuthHeader();
    const response = await api.put('/api/images/order', data, authHeader);
    return response.data;
  },
  
  // Fotoƒüraf a√ßƒ±klamasƒ±nƒ± g√ºncelleme
  async updatePhotoDescription(photoId: string, data: PhotoDescriptionRequest): Promise<any> {
    const authHeader = await createAuthHeader();
    const response = await api.put(`/api/images/${photoId}/description`, data, authHeader);
    return response.data;
  },

  getDiscoverUsers: async (page: number = 1, limit: number = 10, refresh: boolean = false): Promise<DiscoverResponse> => {
    const authHeader = await createAuthHeader();
    console.log(`üîç [API] Discover users √ßaƒürƒ±sƒ± - page: ${page}, limit: ${limit}, refresh: ${refresh}`);
    try {
      const response = await api.get(`/api/swipes/discover?refresh=${refresh}&page=${page}&limit=${limit}`, authHeader);
      console.log(`‚úÖ [API] Discover users yanƒ±tƒ± - ${response.data.users?.length || 0} kullanƒ±cƒ±, hasMore: ${response.data.hasMore}`);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] userApi.getDiscoverUsers hatasƒ±:', error);
      
      // Hata durumunda mock data d√∂nd√ºr (development i√ßin)
      console.warn('‚ö†Ô∏è [API] Mock data d√∂nd√ºr√ºl√ºyor...');
      return createMockDiscoverResponse();
    }
  },

  getUsersWhoLikedMe: async (page: number, limit: number): Promise<UsersWhoLikedMeResponse> => {
    const authHeader = await createAuthHeader();
    const response = await api.get(`/api/swipes/users-who-liked-me?page=${page}&limit=${limit}`, authHeader);
    return response.data;
  },

  getPremiumStatus: async (): Promise<PremiumStatusResponse> => {
    const authHeader = await createAuthHeader();
    const response = await api.get('/api/premium/status', authHeader);
    return response.data;
  },

  swipe: async (data: SwipeRequest): Promise<SwipeResponse> => {
    const authHeader = await createAuthHeader();
    
    console.log('üîÑ [API] userApi.swipe √ßaƒürƒ±sƒ±:', data);
    console.log('üîß [API] userApi.swipe headers:', {
      hasAuth: !!authHeader.headers['Authorization'],
      hasRefreshToken: !!authHeader.headers['X-Refresh-Token']
    });
    
    try {
      const response = await api.post('/api/swipes', data, authHeader);
      console.log('‚úÖ [API] userApi.swipe yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] userApi.swipe hatasƒ±:', {
        status: error.response?.status,
        data: error.response?.data,
        message: error.message
      });
      
      if (error.response?.status === 403) {
        console.error('üîí [API] userApi.swipe 403 Forbidden:', {
          headers: error.response.headers,
          data: error.response.data
        });
      }
      
      throw error;
    }
  },
};

// Premium i≈ülemleri i√ßin API
export const premiumApi = {
  // Premium √∂zelliklerini ve durumunu getirme
  async getFeatures(): Promise<PremiumStatus> {
    const authHeader = await createAuthHeader();
    const response = await api.get('/api/premium/features', authHeader);
    return response.data;
  },
  
  // Premium satƒ±n alma
  async purchase(data: PremiumPurchaseRequest): Promise<PremiumPurchaseResponse> {
    const authHeader = await createAuthHeader();
    const response = await api.post('/api/premium/purchase', data, authHeader);
    return response.data;
  },
  
  // Premium iptal etme
  async cancel(): Promise<PremiumCancelResponse> {
    const authHeader = await createAuthHeader();
    const response = await api.post('/api/premium/cancel', {}, authHeader);
    return response.data;
  }
};

// Swipe cleanup API'leri
export const swipeCleanupApi = {
  // Swipe kayƒ±tlarƒ±nƒ± temizle (2 g√ºnl√ºk otomatik)
  async cleanupSwipes(): Promise<{ success: boolean; deletedCount: number; message: string }> {
    console.log('üîÑ [API] Swipe cleanup √ßaƒürƒ±sƒ± (2 g√ºnl√ºk)');
    const authHeader = await createAuthHeader();
    try {
      const response = await api.post('/api/swipes/cleanup', {}, authHeader);
      console.log('‚úÖ [API] Swipe cleanup yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] Swipe cleanup hatasƒ±:', error.response?.data || error.message);
      throw error;
    }
  },

  // √ñzel g√ºn sayƒ±sƒ± ile swipe kayƒ±tlarƒ±nƒ± temizle
  async cleanupSwipesByDays(daysOld: number): Promise<{ success: boolean; deletedCount: number; message: string }> {
    console.log(`üîÑ [API] Swipe cleanup √ßaƒürƒ±sƒ± (${daysOld} g√ºnl√ºk)`);
    const authHeader = await createAuthHeader();
    try {
      const response = await api.post(`/api/swipes/cleanup?daysOld=${daysOld}`, {}, authHeader);
      console.log('‚úÖ [API] Swipe cleanup yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] Swipe cleanup hatasƒ±:', error.response?.data || error.message);
      throw error;
    }
  },

  // Ka√ß kayƒ±t silineceƒüini √∂ƒüren
  async getCleanupStats(daysOld: number = 2): Promise<{ oldSwipesCount: number; message: string }> {
    console.log(`üîÑ [API] Swipe cleanup stats √ßaƒürƒ±sƒ± (${daysOld} g√ºnl√ºk)`);
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get(`/api/swipes/cleanup/stats?daysOld=${daysOld}`, authHeader);
      console.log('‚úÖ [API] Swipe cleanup stats yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] Swipe cleanup stats hatasƒ±:', error.response?.data || error.message);
      throw error;
    }
  }
};

// Swipe API'leri - Yeni Backend Sistemi
export const swipeApi = {
  // Ana discover endpoint - Yeni backend sistemi (15'li batch desteƒüi)
  getDiscoverUsers: async (
    refresh: boolean = false, 
    showLikedMe: boolean = false, 
    page: number = 1, 
    limit: number = 15
  ): Promise<DiscoverResponse> => {
    console.log('üîÑ [API] getDiscoverUsers √ßaƒürƒ±sƒ±:', { refresh, showLikedMe, page, limit });
    const authHeader = await createAuthHeader();
    
    try {
      // Yeni backend endpoint'i kullan (15'li batch desteƒüi)
      const url = `/api/swipes/discover?refresh=${refresh}&showLikedMe=${showLikedMe}&page=${page}&limit=${limit}&batchSize=15`;
      console.log('üîç [API] Discover isteƒüi g√∂nderiliyor (15\'li batch):', url);
      
      const response = await api.get(url, authHeader);
      
      // Backend'den gelen response formatƒ±nƒ± normalize et
      const normalizedResponse = normalizeDiscoverResponse(response.data, refresh, showLikedMe, page, limit);
      
      console.log('‚úÖ [API] getDiscoverUsers yanƒ±tƒ±:', {
        success: normalizedResponse.success,
        userCount: normalizedResponse.users?.length || 0,
        totalCount: normalizedResponse.totalCount,
        returnedCount: normalizedResponse.returnedCount,
        hasMore: normalizedResponse.hasMore,
        cooldownInfo: normalizedResponse.cooldownInfo,
        swipeLimitInfo: normalizedResponse.swipeLimitInfo,
        refresh: refresh,
        showLikedMe: showLikedMe,
        page: page,
        limit: limit,
        endpoint: url
      });
      
      return normalizedResponse;
    } catch (error: any) {
      console.error('‚ùå [API] getDiscoverUsers hatasƒ±:', {
        message: error.message,
        status: error.response?.status,
        data: error.response?.data,
        requestParams: { refresh, showLikedMe, page, limit }
      });
      
      // Token hatasƒ± ise kullanƒ±cƒ±yƒ± bilgilendir
      if (error.message.includes('Token bulunamadƒ±') || error.message.includes('Oturum s√ºresi dolmu≈ü')) {
        console.warn('‚ö†Ô∏è [API] Token hatasƒ± - Kullanƒ±cƒ± giri≈ü yapmamƒ±≈ü');
        throw new Error('L√ºtfen √∂nce giri≈ü yapƒ±n');
      }
      
      // Diƒüer hatalarda mock data d√∂nd√ºr (development i√ßin)
      console.warn('‚ö†Ô∏è [API] Mock data d√∂nd√ºr√ºl√ºyor...');
      return createMockDiscoverResponse();
    }
  },

  // Normal discover - ƒ∞lk giri≈ü i√ßin
  getNormalDiscover: async (page: number = 1, limit: number = 10): Promise<DiscoverResponse> => {
    return swipeApi.getDiscoverUsers(false, false, page, limit);
  },

  // Yenileme - Cooldown s√ºresi ge√ßmi≈ü kullanƒ±cƒ±lar i√ßin
  getRefreshDiscover: async (page: number = 1, limit: number = 10): Promise<DiscoverResponse> => {
    return swipeApi.getDiscoverUsers(true, false, page, limit);
  },

  // Premium √∂zellik - Beni beƒüenenleri g√∂r
  getLikedMeDiscover: async (page: number = 1, limit: number = 10): Promise<DiscoverResponse> => {
    return swipeApi.getDiscoverUsers(false, true, page, limit);
  },

  // Eski endpoint'ler - Geriye uyumluluk i√ßin
  getAllUsers: async (limit: number = 20): Promise<DiscoverResponse> => {
    console.log('üîÑ [API] getAllUsers √ßaƒürƒ±sƒ± (eski endpoint):', { limit });
    return swipeApi.getNormalDiscover(1, limit);
  },

  // Potansiyel e≈üle≈ümeleri getir - Ana endpoint
  getPotentialMatches: async (page: number = 1, limit: number = 10): Promise<PotentialMatchesResponse> => {
    console.log('üîÑ [API] getPotentialMatches √ßaƒürƒ±sƒ±:', { page, limit });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get(`/api/swipes/potential-matches?page=${page}&limit=${limit}`, authHeader);
      console.log('‚úÖ [API] getPotentialMatches yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getPotentialMatches hatasƒ±:', error.response?.data || error.message);
      
      // Hata durumunda bo≈ü response d√∂nd√ºr
      console.warn('‚ö†Ô∏è [API] Bo≈ü response d√∂nd√ºr√ºl√ºyor...');
      return {
        users: [],
        totalCount: 0,
        hasMore: false
      };
    }
  },



  // Ba≈üka bir alternatif - Discover endpoint (Eski)
  getDiscoverUsersOld: async (page: number = 1, limit: number = 10): Promise<PotentialMatchesResponse> => {
    console.log('üîÑ [API] getDiscoverUsersOld √ßaƒürƒ±sƒ±:', { page, limit });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get(`/api/discover?page=${page}&limit=${limit}`, authHeader);
      console.log('‚úÖ [API] getDiscoverUsersOld yanƒ±tƒ±:', response.data);
      
      // Response formatƒ±nƒ± PotentialMatchesResponse'a uyarla
      if (response.data.users) {
        return {
          users: response.data.users.map((user: any) => ({
            ...user,
            photos: user.photos || (user.profileImageUrl ? [user.profileImageUrl] : []),
            compatibilityScore: user.compatibilityScore || 50,
            compatibilityDescription: user.compatibilityDescription || 'Uyumluluk hesaplanƒ±yor...',
            distance: user.distance || 0,
            isOnline: user.isOnline || false
          })),
          totalCount: response.data.totalCount || response.data.users.length,
          hasMore: response.data.hasMore || false
        };
      }
      
      return { users: [], totalCount: 0, hasMore: false };
    } catch (error: any) {
      console.error('‚ùå [API] getDiscoverUsersOld hatasƒ±:', error.response?.data || error.message);
      throw error;
    }
  },

  // Swipe i≈ülemi yap - Yeni backend sistemi
  swipe: async (swipeData: SwipeRequest): Promise<SwipeResponse> => {
    console.log('üîÑ [API] swipe √ßaƒürƒ±sƒ±:', swipeData);
    const authHeader = await createAuthHeader();
    
    console.log('üîß [API] Swipe headers:', {
      hasAuth: !!authHeader.headers['Authorization'],
      hasRefreshToken: !!authHeader.headers['X-Refresh-Token'],
      authPreview: authHeader.headers['Authorization']?.substring(0, 20) + '...',
      refreshPreview: authHeader.headers['X-Refresh-Token']?.substring(0, 20) + '...'
    });
    
    // Token kontrol√º
    if (!authHeader.headers['Authorization']) {
      console.error('‚ùå [API] Authorization token eksik');
      throw new Error('Oturum s√ºresi dolmu≈ü. L√ºtfen tekrar giri≈ü yapƒ±n.');
    }
    
    if (!authHeader.headers['X-Refresh-Token']) {
      console.error('‚ö†Ô∏è [API] Refresh token eksik');
    }
    
    try {
      // Backend'de toUserId alanƒ± bekleniyor
      const requestData = {
        action: swipeData.action,
        toUserId: swipeData.userId || swipeData.toUserId // Backend formatƒ±na uygun
      };
      
      console.log('üì§ [API] Swipe request data:', requestData);
      
      const response = await api.post('/api/swipes', requestData, authHeader);
      console.log('‚úÖ [API] swipe yanƒ±tƒ±:', response.data);
      
      // Yeni backend sistemi yanƒ±t bilgilerini log'la
      if (response.data.swipeLimitInfo) {
        console.log('üìä [API] Swipe limit bilgisi:', {
          isPremium: response.data.swipeLimitInfo.isPremium,
          remainingSwipes: response.data.swipeLimitInfo.remainingSwipes,
          canSwipe: response.data.swipeLimitInfo.canSwipe,
          nextResetTime: response.data.swipeLimitInfo.nextResetTime
        });
      }
      
      if (response.data.cooldownInfo) {
        console.log('‚è∞ [API] Cooldown bilgisi:', {
          canRefresh: response.data.cooldownInfo.canRefresh,
          nextRefreshTime: response.data.cooldownInfo.nextRefreshTime,
          remainingSeconds: response.data.cooldownInfo.remainingSeconds
        });
      }
      
      // Eski sistem uyumluluƒüu i√ßin
      if (response.data.remainingSwipes !== undefined) {
        console.log('üìä [API] Kalan swipe hakkƒ± (eski sistem):', response.data.remainingSwipes);
      }
      
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] swipe hatasƒ±:', {
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data,
        message: error.message,
        swipeData: swipeData
      });
      
      // √ñzel hata durumlarƒ±
      if (error.response?.status === 403) {
        console.error('üîí [API] 403 Forbidden - Yetki hatasƒ±:', {
          headers: error.response.headers,
          data: error.response.data,
          url: error.response.config?.url
        });
        
        // 403 hatasƒ± i√ßin √∂zel mesaj
        const errorMessage = error.response?.data?.message || 'Yetki hatasƒ±: Bu i≈ülemi ger√ßekle≈ütirme yetkiniz yok';
        throw new Error(errorMessage);
      }
      
      // 400 hatasƒ± - Ge√ßersiz request
      if (error.response?.status === 400) {
        console.error('‚ùå [API] 400 Bad Request:', error.response.data);
        const errorMessage = error.response?.data?.message || 'Ge√ßersiz istek';
        throw new Error(errorMessage);
      }
      
      // 429 hatasƒ± - Rate limit
      if (error.response?.status === 429) {
        console.error('‚è∞ [API] 429 Too Many Requests:', error.response.data);
        const errorMessage = '√áok fazla istek g√∂nderdiniz. L√ºtfen bir s√ºre bekleyip tekrar deneyin.';
        throw new Error(errorMessage);
      }
      
      // 409 hatasƒ± - Duplicate swipe
      if (error.response?.status === 409) {
        console.error('üîÑ [API] 409 Conflict - Duplicate swipe:', error.response.data);
        const errorMessage = error.response?.data?.message || 'Bu kullanƒ±cƒ±ya zaten swipe yaptƒ±nƒ±z';
        throw new Error(errorMessage);
      }
      
      // 412 hatasƒ± - Swipe limit a≈üƒ±mƒ±
      if (error.response?.status === 412) {
        console.error('‚ö†Ô∏è [API] 412 Precondition Failed - Swipe limit:', error.response.data);
        const errorMessage = error.response?.data?.message || 'G√ºnl√ºk swipe limitiniz dolmu≈ü. Premium √ºyelik ile sƒ±nƒ±rsƒ±z swipe yapabilirsiniz.';
        throw new Error(errorMessage);
      }
      
      throw error;
    }
  },

  // Y√ºksek uyumluluk e≈üle≈ümeleri
  getHighCompatibilityMatches: async (minScore: number = 70): Promise<HighCompatibilityMatchesResponse> => {
    console.log('üîÑ [API] getHighCompatibilityMatches √ßaƒürƒ±sƒ±:', { minScore });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get(`/api/matches/high-compatibility?minScore=${minScore}`, authHeader);
      console.log('‚úÖ [API] getHighCompatibilityMatches yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getHighCompatibilityMatches hatasƒ±:', error.response?.data || error.message);
      
      // Hata durumunda bo≈ü response d√∂nd√ºr
      console.warn('‚ö†Ô∏è [API] Bo≈ü response d√∂nd√ºr√ºl√ºyor...');
      return {
        matches: [],
        totalCount: 0
      };
    }
  },

  // Beni beƒüenen kullanƒ±cƒ±larƒ± getir
  getUsersWhoLikedMe: async (limit: number = 10): Promise<UsersWhoLikedMeResponse> => {
    console.log('üîÑ [API] getUsersWhoLikedMe √ßaƒürƒ±sƒ±:', { limit });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get(`/api/swipes/users-who-liked-me?limit=${limit}`, authHeader);
      console.log('‚úÖ [API] getUsersWhoLikedMe yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getUsersWhoLikedMe hatasƒ±:', error.response?.data || error.message);
      
      // Hata durumunda bo≈ü response d√∂nd√ºr
      console.warn('‚ö†Ô∏è [API] Bo≈ü response d√∂nd√ºr√ºl√ºyor...');
      return {
        success: true,
        users: [],
        totalCount: 0,
        hasMore: false,
        currentPage: 1,
        limit: limit
      };
    }
  },

  // Swipe limit durumunu kontrol et
  getSwipeLimitInfo: async (): Promise<SwipeLimitInfo> => {
    console.log('üîÑ [API] getSwipeLimitInfo √ßaƒürƒ±sƒ±');
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get('/api/swipes/limit-info', authHeader);
      console.log('‚úÖ [API] getSwipeLimitInfo yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getSwipeLimitInfo hatasƒ±:', error.response?.data || error.message);
      
      // Hata durumunda default deƒüerler d√∂nd√ºr
      console.warn('‚ö†Ô∏è [API] Default deƒüerler d√∂nd√ºr√ºl√ºyor...');
      return {
        isPremium: false,
        remainingSwipes: 0,
        dailySwipeCount: 0,
        canSwipe: false
      };
    }
  },

  // Yeni backend sistemi i√ßin yardƒ±mcƒ± fonksiyonlar
  // Cooldown durumunu kontrol et
  getCooldownInfo: async (): Promise<{ canRefresh: boolean; nextRefreshTime: string; remainingSeconds: number; message: string }> => {
    console.log('üîÑ [API] getCooldownInfo √ßaƒürƒ±sƒ±');
    try {
      // Discover endpoint'inden cooldown bilgisini al
      const response = await swipeApi.getDiscoverUsers(false, false, 1, 1);
      return response.cooldownInfo || {
        canRefresh: true,
        nextRefreshTime: new Date().toISOString(),
        remainingSeconds: 0,
        message: 'Yenileme hazƒ±r'
      };
    } catch (error) {
      console.error('‚ùå [API] getCooldownInfo hatasƒ±:', error);
      return {
        canRefresh: true,
        nextRefreshTime: new Date().toISOString(),
        remainingSeconds: 0,
        message: 'Yenileme hazƒ±r'
      };
    }
  },

  // Premium durumunu kontrol et
  isPremiumUser: async (): Promise<boolean> => {
    try {
      const limitInfo = await swipeApi.getSwipeLimitInfo();
      return limitInfo.isPremium;
    } catch (error) {
      console.error('‚ùå [API] isPremiumUser hatasƒ±:', error);
      return false;
    }
  },

  // Swipe yapƒ±labilir mi kontrol et
  canSwipe: async (): Promise<boolean> => {
    try {
      const limitInfo = await swipeApi.getSwipeLimitInfo();
      return limitInfo.canSwipe;
    } catch (error) {
      console.error('‚ùå [API] canSwipe hatasƒ±:', error);
      return false;
    }
  },

  // Swipe limit durumunu detaylƒ± kontrol et
  getSwipeLimitStatus: async (): Promise<{
    canSwipe: boolean;
    remainingSwipes: number;
    isLimitReached: boolean;
    limitMessage: string;
    isPremium: boolean;
    nextResetTime: string;
  }> => {
    try {
      const limitInfo = await swipeApi.getSwipeLimitInfo();
      return {
        canSwipe: limitInfo.canSwipe,
        remainingSwipes: limitInfo.remainingSwipes,
        isLimitReached: limitInfo.isLimitReached || false,
        limitMessage: limitInfo.limitMessage || `Kalan swipe: ${limitInfo.remainingSwipes}`,
        isPremium: limitInfo.isPremium,
        nextResetTime: limitInfo.nextResetTime || new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
      };
    } catch (error) {
      console.error('‚ùå [API] getSwipeLimitStatus hatasƒ±:', error);
      return {
        canSwipe: false,
        remainingSwipes: 0,
        isLimitReached: true,
        limitMessage: 'Swipe limit bilgisi alƒ±namadƒ±',
        isPremium: false,
        nextResetTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
      };
    }
  },

  // Swipe limit uyarƒ±sƒ± g√∂ster
  showSwipeLimitWarning: async (): Promise<void> => {
    try {
      const status = await swipeApi.getSwipeLimitStatus();
      
      if (status.isLimitReached) {
        console.warn('‚ö†Ô∏è [SWIPE] Limit doldu:', status.limitMessage);
        
        // Burada kullanƒ±cƒ±ya uyarƒ± g√∂sterilebilir
        // √ñrneƒüin: Alert, Modal, Toast mesajƒ±
        // showAlert('Swipe Limiti', status.limitMessage);
      } else if (status.remainingSwipes <= 5) {
        console.warn('‚ö†Ô∏è [SWIPE] Limit az kaldƒ±:', status.limitMessage);
        
        // Burada kullanƒ±cƒ±ya uyarƒ± g√∂sterilebilir
        // showAlert('Swipe Limiti', status.limitMessage);
      }
    } catch (error) {
      console.error('‚ùå [API] showSwipeLimitWarning hatasƒ±:', error);
    }
  }
};

// Chat API'leri i√ßin interface'ler
export interface ChatUser {
  id: number;
  username: string;
  firstName: string;
  lastName: string;
  fullName: string;
  profileImageUrl: string | null;
  zodiacSign: string | null;
  zodiacSignDisplay: string | null;
  isPremium: boolean;
  gender: string | null;
  lastActiveTime: string | null;
  activityStatus: string;
  isOnline: boolean;
  displayName: string;
}

export interface PrivateChatRoom {
  id: number;
  type: 'PRIVATE';
  name: string;
  otherUser: ChatUser;
  lastMessage: {
    id: number;
    content: string;
    sentAt: string;
    sender: ChatUser;
  } | null;
  unreadCount: number;
  matchId: number;
  matchType: 'ZODIAC' | 'MUSIC'; // Backend'den gelen match type
  displayName: string;
  timeAgo: string;
}

export interface PrivateChatListResponse {
  success: boolean;
  privateChatRooms: PrivateChatRoom[];
  count: number;
  message: string;
}

export interface ChatMessage {
  id: number;
  chatRoomId: number;
  content: string;
  type: 'TEXT' | 'SYSTEM' | 'IMAGE';
  sentAt: string;
  editedAt: string | null;
  isEdited: boolean;
  status: 'SENT' | 'DELIVERED' | 'READ';
  sender: ChatUser;
  timeAgo: string;
  canEdit: boolean;
  canDelete: boolean;
}

export interface MessageLimitInfo {
  canSendMessage: boolean;
  nextAllowedTime: string | null;
  remainingSeconds: number;
  isPremium: boolean;
  isBanned: boolean;
  message: string;
}

export interface GlobalChatResponse {
  chatRoomId: number;
  chatType: 'GLOBAL';
  chatName: string;
  activeUserCount: number;
  messages: ChatMessage[];
  currentPage: number;
  totalPages: number;
  totalMessages: number;
  hasMore: boolean;
  userMessageLimit: MessageLimitInfo;
  isActive: boolean;
  welcomeMessage: string;
}

export interface PrivateChatResponse {
  chatRoomId: number;
  chatName: string;
  createdAt: string;
  otherUser: ChatUser;
  matchId: number;
  matchType: 'ZODIAC' | 'MUSIC'; // Backend'den gelen match type
  compatibilityScore: number;
  messages: ChatMessage[];
  currentPage: number;
  totalPages: number;
  totalMessages: number;
  hasMore: boolean;
  isActive: boolean;
  unreadCount: number;
  lastActivity: string;
  matchDate: string;
  compatibilityMessage: string;
}

export interface SendGlobalMessageRequest {
  content: string;
}

export interface SendPrivateMessageRequest {
  content: string;
  receiverId: number;
}

export interface SendMessageResponse {
  success: boolean;
  message: ChatMessage;
  info: string;
}

export interface ChatListItem {
  chatRoomId: number;
  chatType: 'GLOBAL' | 'PRIVATE';
  chatName: string;
  lastMessage: ChatMessage | null;
  unreadCount: number;
  lastActivity: string;
  otherUser?: ChatUser;
  matchType?: 'ZODIAC' | 'MUSIC';
  activeUserCount?: number;
}

// Match API'leri
export const matchApi = {
  // T√ºm e≈üle≈ümeleri getir
  getMatches: async (): Promise<{ matches: Match[] }> => {
    console.log('üîÑ [API] getMatches √ßaƒürƒ±sƒ±');
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get('/api/matches', authHeader);
      console.log('‚úÖ [API] getMatches yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getMatches hatasƒ±:', error.response?.data || error.message);
      
      // Hata durumunda bo≈ü response d√∂nd√ºr
      console.warn('‚ö†Ô∏è [API] Bo≈ü response d√∂nd√ºr√ºl√ºyor...');
      return {
        matches: []
      };
    }
  },

  // Belirli bir e≈üle≈üme detayƒ±
  getMatchDetail: async (matchId: number): Promise<Match> => {
    console.log('üîÑ [API] getMatchDetail √ßaƒürƒ±sƒ±:', { matchId });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get(`/api/matches/${matchId}`, authHeader);
      console.log('‚úÖ [API] getMatchDetail yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getMatchDetail hatasƒ±:', error.response?.data || error.message);
      
      // Hata durumunda hata fƒ±rlat (bu fonksiyon i√ßin gerekli)
      throw new Error('E≈üle≈üme detayƒ± alƒ±namadƒ±');
    }
  },

  // E≈üle≈ümeyi sil
  deleteMatch: async (matchId: number): Promise<{ success: boolean }> => {
    console.log('üîÑ [API] deleteMatch √ßaƒürƒ±sƒ±:', { matchId });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.delete(`/api/matches/${matchId}`, authHeader);
      console.log('‚úÖ [API] deleteMatch yanƒ±tƒ±:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] deleteMatch hatasƒ±:', error.response?.data || error.message);
      
      // Hata durumunda hata fƒ±rlat (bu fonksiyon i√ßin gerekli)
      throw new Error('E≈üle≈üme silinemedi');
    }
  }
};

// Chat API'leri
export const chatApi = {
  // Private chat listesini getir
  getPrivateChatList: async (): Promise<PrivateChatListResponse> => {
    console.log('üîÑ [API] getPrivateChatList √ßaƒürƒ±sƒ±');
    
    try {
      const authHeader = await createAuthHeader();
      const response = await api.get('/api/chat/private/list', authHeader);
      
      console.log('‚úÖ [API] getPrivateChatList yanƒ±tƒ±:', {
        chatCount: response.data.privateChatRooms?.length || 0,
        success: response.data.success,
        message: response.data.message
      });
      
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getPrivateChatList hatasƒ±:', {
        status: error.response?.status,
        statusText: error.response?.statusText,
        data: error.response?.data,
        message: error.message
      });
      
      // 500 hatasƒ± √∂zel durumu - backend'de kullanƒ±cƒ± bulunamadƒ±
      if (error.response?.status === 500) {
        const errorData = error.response.data;
        if (errorData?.error?.includes('Kullanƒ±cƒ± bulunamadƒ±')) {
          console.error('üîç [API] Backend kullanƒ±cƒ± bulunamadƒ± hatasƒ± - Token problemi tespit edildi');
          
          // Token'ƒ± yeniden kontrol et
          const token = await getToken();
          if (token) {
            const decodedToken = decodeJWT(token);
            console.error('üîç [API] Problematik token i√ßeriƒüi:', decodedToken);
            
            // Token'da sadece username var, userId yok - bu backend JWT konfig√ºrasyon hatasƒ±
            if (decodedToken?.sub && !decodedToken?.userId && !decodedToken?.id) {
              console.error('‚ùå [API] JWT Token yapƒ±landƒ±rma hatasƒ±: Token\'da kullanƒ±cƒ± ID\'si yok, sadece username var');
              console.error('üîß [API] Backend\'de JWT token olu≈üturulurken userId field\'ƒ± eklenmeli');
              
              // Ge√ßici √ß√∂z√ºm: Token'ƒ± yenilemeyi dene
              try {
                console.log('üîÑ [API] Token yenileme deneniyor...');
                await authApi.refreshToken();
                
                // Yenilenen token ile tekrar dene
                const newAuthHeader = await createAuthHeader();
                const retryResponse = await api.get('/api/chat/private/list', newAuthHeader);
                
                console.log('‚úÖ [API] Token yenileme sonrasƒ± ba≈üarƒ±lƒ±:', {
                  chatCount: retryResponse.data.privateChatRooms?.length || 0,
                  success: retryResponse.data.success
                });
                
                return retryResponse.data;
              } catch (refreshError) {
                console.error('‚ùå [API] Token yenileme de ba≈üarƒ±sƒ±z:', refreshError);
              }
            }
          }
          
          // Kullanƒ±cƒ± dostu hata mesajƒ±
          throw new Error('Token yapƒ±landƒ±rma sorunu tespit edildi. Backend geli≈ütiricisi ile ileti≈üime ge√ßin.');
        }
      }
      
      // 401 hatasƒ± - Token ge√ßersiz
      if (error.response?.status === 401) {
        console.error('üîí [API] 401 Unauthorized - Token ge√ßersiz');
        throw new Error('Oturum s√ºresi dolmu≈ü. L√ºtfen tekrar giri≈ü yapƒ±n.');
      }
      
      // Diƒüer hatalar
      throw error;
    }
  },

  // Genel chat mesajlarƒ±nƒ± getir
  getGlobalMessages: async (page: number = 0, size: number = 20): Promise<GlobalChatResponse> => {
    console.log('üîÑ [API] getGlobalMessages √ßaƒürƒ±sƒ±:', { page, size });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get(`/api/chat/global/messages?page=${page}&size=${size}`, authHeader);
      console.log('‚úÖ [API] getGlobalMessages yanƒ±tƒ±:', {
        messageCount: response.data.messages?.length || 0,
        activeUsers: response.data.activeUserCount,
        canSendMessage: response.data.userMessageLimit?.canSendMessage
      });
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getGlobalMessages hatasƒ±:', error.response?.data || error.message);
      throw error;
    }
  },

  // Genel chat'e mesaj g√∂nder
  sendGlobalMessage: async (data: SendGlobalMessageRequest): Promise<SendMessageResponse> => {
    console.log('üîÑ [API] sendGlobalMessage √ßaƒürƒ±sƒ±:', { contentLength: data.content.length });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.post('/api/chat/global/send', data, authHeader);
      console.log('‚úÖ [API] sendGlobalMessage yanƒ±tƒ±: Mesaj g√∂nderildi');
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] sendGlobalMessage hatasƒ±:', {
        status: error.response?.status,
        data: error.response?.data,
        message: error.message
      });
      
      // √ñzel hata durumlarƒ±
      if (error.response?.status === 429) {
        const errorMessage = error.response?.data?.error || 'Mesaj g√∂nderme limiti doldu';
        throw new Error(errorMessage);
      }
      
      if (error.response?.status === 400) {
        const errorMessage = error.response?.data?.error || 'Mesaj i√ßeriƒüi uygunsuz';
        throw new Error(errorMessage);
      }
      
      throw error;
    }
  },

  // Mesaj limiti bilgisini getir
  getMessageLimitInfo: async (): Promise<MessageLimitInfo> => {
    console.log('üîÑ [API] getMessageLimitInfo √ßaƒürƒ±sƒ±');
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get('/api/chat/limit-info', authHeader);
      console.log('‚úÖ [API] getMessageLimitInfo yanƒ±tƒ±:', {
        canSendMessage: response.data.canSendMessage,
        isPremium: response.data.isPremium,
        remainingSeconds: response.data.remainingSeconds
      });
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getMessageLimitInfo hatasƒ±:', error.response?.data || error.message);
      throw error;
    }
  },

  // Mesaj durumlarƒ±nƒ± g√ºncelle (sadece durum kontrol√º i√ßin)
  updateMessageStatuses: async (chatRoomId: number, messageIds: number[]): Promise<{ [key: number]: string }> => {
    console.log('üîÑ [API] updateMessageStatuses √ßaƒürƒ±sƒ±:', { chatRoomId, messageCount: messageIds.length });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.post('/api/chat/message-statuses', {
        chatRoomId,
        messageIds
      }, authHeader);
      
      console.log('‚úÖ [API] updateMessageStatuses yanƒ±tƒ±:', {
        updatedCount: Object.keys(response.data).length
      });
      return response.data; // { messageId: status } formatƒ±nda
    } catch (error: any) {
      console.error('‚ùå [API] updateMessageStatuses hatasƒ±:', error.response?.data || error.message);
      throw error;
    }
  },

  // √ñzel chat mesajlarƒ±nƒ± getir
  getPrivateMessages: async (chatRoomId: number, page: number = 0, size: number = 20): Promise<PrivateChatResponse> => {
    console.log('üîÑ [API] getPrivateMessages √ßaƒürƒ±sƒ±:', { chatRoomId, page, size });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.get(`/api/chat/private/${chatRoomId}/messages?page=${page}&size=${size}`, authHeader);
      
      // otherUser kontrol√º ekle
      if (!response.data.otherUser || !response.data.otherUser.id) {
        console.error('‚ùå [API] getPrivateMessages - otherUser eksik:', {
          hasOtherUser: !!response.data.otherUser,
          otherUserId: response.data.otherUser?.id,
          responseData: response.data
        });
        
        // Backend'den otherUser null geldiƒüinde, chat listesinden almaya √ßalƒ±≈ü
        console.log('üîÑ [API] otherUser eksik, chat listesinden almaya √ßalƒ±≈üƒ±lƒ±yor...');
        try {
          const chatListResponse = await api.get('/api/chat/private/list', authHeader);
          const chatRoom = chatListResponse.data.privateChatRooms?.find((chat: any) => chat.id === chatRoomId);
          
          if (chatRoom && chatRoom.otherUser) {
            console.log('‚úÖ [API] Chat listesinden otherUser bulundu:', chatRoom.otherUser);
            response.data.otherUser = chatRoom.otherUser;
          } else {
            console.error('‚ùå [API] Chat listesinde de otherUser bulunamadƒ±');
            throw new Error('Sohbet bilgileri eksik. L√ºtfen tekrar deneyin.');
          }
        } catch (chatListError) {
          console.error('‚ùå [API] Chat listesi alƒ±namadƒ±:', chatListError);
          throw new Error('Sohbet bilgileri eksik. L√ºtfen tekrar deneyin.');
        }
      }
      
      console.log('‚úÖ [API] getPrivateMessages yanƒ±tƒ±:', {
        messageCount: response.data.messages?.length || 0,
        otherUser: response.data.otherUser?.displayName,
        otherUserId: response.data.otherUser?.id,
        unreadCount: response.data.unreadCount
      });
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] getPrivateMessages hatasƒ±:', {
        status: error.response?.status,
        data: error.response?.data,
        chatRoomId
      });
      
      if (error.response?.status === 403) {
        throw new Error('Bu sohbete eri≈üim yetkiniz yok');
      }
      
      throw error;
    }
  },

  // √ñzel mesaj g√∂nder
  sendPrivateMessage: async (data: SendPrivateMessageRequest): Promise<SendMessageResponse> => {
    console.log('üîÑ [API] sendPrivateMessage √ßaƒürƒ±sƒ±:', { 
      receiverId: data.receiverId, 
      contentLength: data.content.length 
    });
    const authHeader = await createAuthHeader();
    try {
      const response = await api.post('/api/chat/private/send', data, authHeader);
      console.log('‚úÖ [API] sendPrivateMessage yanƒ±tƒ±: √ñzel mesaj g√∂nderildi');
      return response.data;
    } catch (error: any) {
      console.error('‚ùå [API] sendPrivateMessage hatasƒ±:', {
        status: error.response?.status,
        data: error.response?.data,
        receiverId: data.receiverId
      });
      
      // √ñzel hata durumlarƒ±
      if (error.response?.status === 400) {
        const errorMessage = error.response?.data?.error || 'Ge√ßersiz mesaj verisi';
        throw new Error(errorMessage);
      }
      
      if (error.response?.status === 500) {
        const errorMessage = error.response?.data?.error || 'Sunucu hatasƒ±';
        if (errorMessage.includes('Transaction silently rolled back')) {
          throw new Error('Mesaj g√∂nderilemedi. L√ºtfen tekrar deneyin.');
        }
        throw new Error('Sunucu hatasƒ±. L√ºtfen daha sonra tekrar deneyin.');
      }
      
      throw error;
    }
  },

  // Chat listesini getir (hem genel hem √∂zel chatler i√ßin)
  getChatList: async (): Promise<ChatListItem[]> => {
    console.log('üîÑ [API] getChatList √ßaƒürƒ±sƒ±');
    const authHeader = await createAuthHeader();
    try {
      // √ñnce genel chat bilgisini al
      const globalResponse = await api.get('/api/chat/global/messages?page=0&size=1', authHeader);
      
      // Sonra √∂zel chatlarƒ± al (bu endpoint backend'de olu≈üturulmalƒ±)
      let privateChats: ChatListItem[] = [];
      try {
        const privateResponse = await api.get('/api/chat/private/list', authHeader);
        privateChats = privateResponse.data.chats || [];
      } catch (error) {
        console.warn('Private chat list alƒ±namadƒ±:', error);
      }

      // Chat listesini birle≈ütir
      const chatList: ChatListItem[] = [
        // Genel chat
        {
          chatRoomId: globalResponse.data.chatRoomId,
          chatType: 'GLOBAL' as const,
          chatName: 'üåç Genel Sohbet',
          lastMessage: globalResponse.data.messages?.[0] || null,
          unreadCount: 0,
          lastActivity: globalResponse.data.messages?.[0]?.sentAt || new Date().toISOString(),
          activeUserCount: globalResponse.data.activeUserCount
        },
        // √ñzel chatlar
        ...privateChats
      ];

      console.log('‚úÖ [API] getChatList yanƒ±tƒ±:', {
        totalChats: chatList.length,
        globalActiveUsers: globalResponse.data.activeUserCount,
        privateChats: privateChats.length
      });
      
      return chatList;
    } catch (error: any) {
      console.error('‚ùå [API] getChatList hatasƒ±:', error.response?.data || error.message);
      throw error;
    }
  }
};

// Otomatik token yenileme fonksiyonlarƒ±nƒ± export et
export { startAutoTokenRefresh, stopAutoTokenRefresh };

export default api; 