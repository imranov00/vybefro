import React, { createContext, ReactNode, useContext, useEffect, useRef, useState } from 'react';
import { Alert } from 'react-native';
import { chatApi, ChatListItem, ChatMessage, GlobalChatResponse, MessageLimitInfo, PrivateChatResponse, PrivateChatRoom, userApi } from '../services/api';
import {
  initializeWebSocket,
  VybeWebSocketClient,
  WebSocketMessage,
  WebSocketMessageType,
  WebSocketStatus
} from '../services/websocket';
import { getToken } from '../utils/tokenStorage';

// Context deƒüer tipi
type ChatContextType = {
  // Chat listesi
  chatList: ChatListItem[];
  isLoadingChatList: boolean;
  refreshChatList: () => Promise<void>;
  
  // Private chat listesi
  privateChatList: PrivateChatRoom[];
  isLoadingPrivateChats: boolean;
  refreshPrivateChats: () => Promise<void>;
  
  // Aktif chat
  activeChat: GlobalChatResponse | PrivateChatResponse | null;
  activeChatId: number | null;
  isLoadingMessages: boolean;
  
  // Mesaj i≈ülemleri
  sendGlobalMessage: (content: string) => Promise<boolean>;
  sendPrivateMessage: (content: string, receiverId: number) => Promise<boolean>;
  loadMessages: (chatRoomId: number, chatType: 'GLOBAL' | 'PRIVATE') => Promise<void>;
  loadMoreMessages: () => Promise<void>;
  
  // Mesaj limiti
  messageLimitInfo: MessageLimitInfo | null;
  refreshMessageLimit: () => Promise<void>;
  
  // Real-time g√ºncelleme
  addNewMessage: (message: ChatMessage) => void;
  replaceMessage: (oldId: number, newMessage: ChatMessage) => void;
  markMessagesAsRead: (chatRoomId: number) => void;
  
  // UI durumu
  isTyping: boolean;
  setIsTyping: (typing: boolean) => void;
  
  // Real-time polling kontrol√º
  setFastPolling: (enabled: boolean) => void;
  
  // WebSocket durumu
  wsStatus: WebSocketStatus;
  wsClient: VybeWebSocketClient | null;
  
  // WebSocket i≈ülemleri
  joinChatRoom: (chatRoomId: string) => void;
  leaveChatRoom: (chatRoomId: string) => void;
  sendTypingIndicator: (chatRoomId: string, isTyping: boolean) => void;
  updateMessageStatus: (messageId: string, chatRoomId: string, status: 'DELIVERED' | 'READ') => void;
  
  // Typing indicator'lar
  typingUsers: Map<string, Set<string>>; // chatRoomId -> Set<userId>
  
  // Hata y√∂netimi
  error: string | null;
  clearError: () => void;
  
  // Hybrid yakla≈üƒ±m i√ßin yeni √∂zellikler
  isWebSocketConnected: boolean;
  pendingMessages: Set<string>; // G√∂nderilen ama hen√ºz WebSocket'ten gelmeyen mesajlar
  forceRefreshMessages: () => Promise<void>;
};

// Context olu≈ütur
const ChatContext = createContext<ChatContextType | undefined>(undefined);

// Context Provider bile≈üeni
export function ChatProvider({ children }: { children: ReactNode }) {
  // State'ler
  const [chatList, setChatList] = useState<ChatListItem[]>([]);
  const [isLoadingChatList, setIsLoadingChatList] = useState(false);
  const [privateChatList, setPrivateChatList] = useState<PrivateChatRoom[]>([]);
  const [isLoadingPrivateChats, setIsLoadingPrivateChats] = useState(false);
  
  const [activeChat, setActiveChat] = useState<GlobalChatResponse | PrivateChatResponse | null>(null);
  const [activeChatId, setActiveChatId] = useState<number | null>(null);
  const [isLoadingMessages, setIsLoadingMessages] = useState(false);
  
  const [messageLimitInfo, setMessageLimitInfo] = useState<MessageLimitInfo | null>(null);
  const [isTyping, setIsTyping] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [fastPolling, setFastPolling] = useState(false);
  
  // WebSocket state'leri
  const [wsStatus, setWsStatus] = useState<WebSocketStatus>(WebSocketStatus.DISCONNECTED);
  const [wsClient, setWsClient] = useState<VybeWebSocketClient | null>(null);
  const [typingUsers, setTypingUsers] = useState<Map<string, Set<string>>>(new Map());
  
  // Hybrid yakla≈üƒ±m i√ßin yeni state'ler
  const [isWebSocketConnected, setIsWebSocketConnected] = useState(false);
  const [pendingMessages, setPendingMessages] = useState<Set<string>>(new Set());
  
  // Ref'ler
  const wsClientRef = useRef<VybeWebSocketClient | null>(null);
  const typingUsersRef = useRef<Map<string, Set<string>>>(new Map());
  const pendingMessagesRef = useRef<Set<string>>(new Set());
  const lastMessageCheckRef = useRef<number>(0);

  // Chat listesini y√ºkle
  const refreshChatList = async () => {
    try {
      setIsLoadingChatList(true);
      setError(null);
      
      const chatListData = await chatApi.getChatList();
      setChatList(chatListData);
      
      console.log('‚úÖ [CHAT CONTEXT] Chat listesi y√ºklendi:', chatListData.length);
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Chat listesi y√ºklenemedi:', error);
      setError('Chat listesi y√ºklenemedi');
    } finally {
      setIsLoadingChatList(false);
    }
  };

  // Private chat listesini yenile
  const refreshPrivateChats = async () => {
    try {
      setIsLoadingPrivateChats(true);
      console.log('üîÑ [CHAT CONTEXT] Private chat listesi yenileniyor...');
      
      const privateChatData = await chatApi.getPrivateChatList();
      setPrivateChatList(privateChatData.privateChatRooms);
      
      console.log('‚úÖ [CHAT CONTEXT] Private chat listesi y√ºklendi:', privateChatData.privateChatRooms.length);
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Private chat listesi y√ºklenemedi:', error);
      
      // Oturum problemi varsa kullanƒ±cƒ±yƒ± bilgilendir
      if (error.message?.includes('Oturum bilgilerinizde bir sorun var') || 
          error.message?.includes('Oturum s√ºresi dolmu≈ü')) {
        setError(error.message);
      } else {
        // Diƒüer hatalar i√ßin sessizce ge√ß, kritik deƒüil
        console.log('‚ÑπÔ∏è [CHAT CONTEXT] Private chat hatasƒ± g√∂rmezden geliniyor');
      }
    } finally {
      setIsLoadingPrivateChats(false);
    }
  };

  // Mesajlarƒ± y√ºkle
  const loadMessages = async (chatRoomId: number, chatType: 'GLOBAL' | 'PRIVATE') => {
    try {
      setIsLoadingMessages(true);
      setError(null);
      setActiveChatId(chatRoomId);
      
      let chatData: GlobalChatResponse | PrivateChatResponse;
      
      if (chatType === 'GLOBAL') {
        chatData = await chatApi.getGlobalMessages(0, 20);
        
        // Global chat i√ßin limit bilgisini de g√ºncelle
        if (chatData.userMessageLimit) {
          setMessageLimitInfo(chatData.userMessageLimit);
          console.log('‚úÖ [CHAT CONTEXT] Global chat limit bilgisi g√ºncellendi:', chatData.userMessageLimit);
        }
      } else {
        chatData = await chatApi.getPrivateMessages(chatRoomId, 0, 20);
        
        // Private chat i√ßin otherUser kontrol√º
        if (!('chatType' in chatData) && (!chatData.otherUser || !chatData.otherUser.id)) {
          console.error('‚ùå [CHAT CONTEXT] Private chat otherUser eksik:', {
            hasOtherUser: !!chatData.otherUser,
            otherUserId: chatData.otherUser?.id,
            chatData: chatData
          });
          
          // Chat listesinden otherUser bilgisini almaya √ßalƒ±≈ü
          console.log('üîÑ [CHAT CONTEXT] Chat listesinden otherUser almaya √ßalƒ±≈üƒ±lƒ±yor...');
          try {
            await refreshPrivateChats();
            const chatRoom = privateChatList.find(chat => chat.id === chatRoomId);
            
            if (chatRoom && chatRoom.otherUser) {
              console.log('‚úÖ [CHAT CONTEXT] Chat listesinden otherUser bulundu:', chatRoom.otherUser);
              chatData.otherUser = chatRoom.otherUser;
            } else {
              console.error('‚ùå [CHAT CONTEXT] Chat listesinde de otherUser bulunamadƒ±');
              throw new Error('Sohbet bilgileri eksik. L√ºtfen tekrar deneyin.');
            }
          } catch (fallbackError) {
            console.error('‚ùå [CHAT CONTEXT] Fallback otherUser alma hatasƒ±:', fallbackError);
            throw new Error('Sohbet bilgileri eksik. L√ºtfen tekrar deneyin.');
          }
        }
      }
      
      setActiveChat(chatData);
      
      console.log('‚úÖ [CHAT CONTEXT] Mesajlar y√ºklendi:', {
        chatRoomId,
        chatType,
        messageCount: chatData.messages.length
      });
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Mesajlar y√ºklenemedi:', error);
      
      // √ñzel hata mesajlarƒ±
      if (error.message?.includes('Sohbet bilgileri eksik')) {
        setError('Sohbet bilgileri eksik. Sayfayƒ± yenileyin.');
      } else {
        setError('Mesajlar y√ºklenemedi');
      }
    } finally {
      setIsLoadingMessages(false);
    }
  };

  // Daha fazla mesaj y√ºkle (pagination)
  const loadMoreMessages = async () => {
    if (!activeChat || !activeChatId || isLoadingMessages || !activeChat.hasMore) {
      return;
    }

    try {
      setIsLoadingMessages(true);
      
      const nextPage = activeChat.currentPage + 1;
      let newChatData: GlobalChatResponse | PrivateChatResponse;
      
      if ('chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
        newChatData = await chatApi.getGlobalMessages(nextPage, 20);
      } else {
        newChatData = await chatApi.getPrivateMessages(activeChatId, nextPage, 20);
      }
      
      // Mevcut mesajlarƒ± yeni mesajlarla birle≈ütir
      setActiveChat(prevChat => {
        if (!prevChat) return newChatData;
        
        return {
          ...prevChat,
          messages: [...prevChat.messages, ...newChatData.messages],
          currentPage: newChatData.currentPage,
          hasMore: newChatData.hasMore
        };
      });
      
      console.log('‚úÖ [CHAT CONTEXT] Daha fazla mesaj y√ºklendi:', newChatData.messages.length);
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Daha fazla mesaj y√ºklenemedi:', error);
    } finally {
      setIsLoadingMessages(false);
    }
  };

  // Genel chat'e mesaj g√∂nder - Ger√ßek Optimistic Update
  const sendGlobalMessage = async (content: string): Promise<boolean> => {
    console.log('üîÑ [CHAT CONTEXT] sendGlobalMessage ba≈ülatƒ±ldƒ±:', {
      content: content.substring(0, 50),
      activeChat: activeChat ? 'var' : 'yok',
      chatType: activeChat && 'chatType' in activeChat ? activeChat.chatType : 'bilinmiyor',
      wsConnected: isWebSocketConnected
    });
    
    try {
      setError(null);
      
      // 1. OPTIMISTIC UPDATE - Mesajƒ± hemen UI'da g√∂ster
      const optimisticMessage: ChatMessage = {
        id: Date.now(), // Ge√ßici ID
        chatRoomId: 1,
        content: content,
        type: 'TEXT',
        sentAt: new Date().toISOString(),
        editedAt: null,
        isEdited: false,
        status: 'SENT',
        sender: {
          id: 24, // Ge√ßici sender ID
          username: 'teo',
          firstName: 'Teo',
          lastName: 'User',
          fullName: 'Teo User',
          profileImageUrl: null,
          zodiacSign: 'GEMINI',
          zodiacSignDisplay: '‚ôä ƒ∞kizler',
          isPremium: false,
          gender: 'MALE',
          lastActiveTime: new Date().toISOString(),
          activityStatus: 'ONLINE',
          isOnline: true,
          displayName: 'Teo User'
        },
        timeAgo: '≈ûimdi',
        canEdit: false,
        canDelete: false
      };
      
      if (activeChat && 'chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
        console.log('‚ö° [CHAT CONTEXT] Optimistic mesaj UI\'da g√∂steriliyor');
        addNewMessage(optimisticMessage);
      }
      
      // 2. API'ye mesajƒ± g√∂nder
      const response = await chatApi.sendGlobalMessage({ content });
      const messageId = response.message.id.toString();
      
      console.log('‚úÖ [CHAT CONTEXT] API yanƒ±tƒ± alƒ±ndƒ±:', messageId);
      
      // 3. Optimistic mesajƒ± ger√ßek mesajla deƒüi≈ütir
      if (activeChat && 'chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
        console.log('üîÑ [CHAT CONTEXT] Optimistic mesaj ger√ßek mesajla deƒüi≈ütiriliyor');
        replaceMessage(optimisticMessage.id, response.message);
      }
      
      // 4. Pending mesajlara ekle (WebSocket'ten gelene kadar)
      setPendingMessages(prev => new Set([...prev, messageId]));
      pendingMessagesRef.current.add(messageId);
      
      // 4. Mesaj g√∂nderimi sonrasƒ± kƒ±sa s√ºreli polling (sayfa yenileme sorununu √ß√∂zer)
      console.log('üîÑ [CHAT CONTEXT] Mesaj g√∂nderimi sonrasƒ± polling ba≈ülatƒ±lƒ±yor...');
      
      // ƒ∞lk polling: 2 saniye sonra
      setTimeout(async () => {
        try {
          if (activeChat && 'chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
            console.log('üîÑ [CHAT CONTEXT] ƒ∞lk polling yapƒ±lƒ±yor...');
            const newChatData = await chatApi.getGlobalMessages(0, 20);
            
            // Yeni mesajlarƒ± kontrol et ve ekle
            const currentMessageIds = activeChat.messages.map(m => m.id);
            const newMessages = newChatData.messages.filter(m => !currentMessageIds.includes(m.id));
            
            if (newMessages.length > 0) {
              console.log(`üÜï [CHAT CONTEXT] ƒ∞lk polling'de ${newMessages.length} yeni mesaj bulundu`);
              newMessages.reverse().forEach(message => {
                addNewMessage(message);
                // Pending mesajlardan √ßƒ±kar
                pendingMessagesRef.current.delete(message.id.toString());
              });
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [CHAT CONTEXT] ƒ∞lk polling hatasƒ±:', error);
        }
      }, 2000);
      
      // ƒ∞kinci polling: 5 saniye sonra (g√ºvenlik i√ßin)
      setTimeout(async () => {
        try {
          if (activeChat && 'chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
            console.log('üîÑ [CHAT CONTEXT] ƒ∞kinci polling yapƒ±lƒ±yor...');
            const newChatData = await chatApi.getGlobalMessages(0, 20);
            
            // Yeni mesajlarƒ± kontrol et ve ekle
            const currentMessageIds = activeChat.messages.map(m => m.id);
            const newMessages = newChatData.messages.filter(m => !currentMessageIds.includes(m.id));
            
            if (newMessages.length > 0) {
              console.log(`üÜï [CHAT CONTEXT] ƒ∞kinci polling'de ${newMessages.length} yeni mesaj bulundu`);
              newMessages.reverse().forEach(message => {
                addNewMessage(message);
                // Pending mesajlardan √ßƒ±kar
                pendingMessagesRef.current.delete(message.id.toString());
              });
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [CHAT CONTEXT] ƒ∞kinci polling hatasƒ±:', error);
        }
      }, 5000);
      
      // 5. Chat listesini g√ºncelle (sadece mesaj eklenmediƒüinde)
      if (!activeChat || !('chatType' in activeChat) || activeChat.chatType !== 'GLOBAL') {
        await refreshChatList();
      }
      
      console.log('‚úÖ [CHAT CONTEXT] Genel mesaj g√∂nderildi');
      return true;
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Genel mesaj g√∂nderilemedi:', error);
      setError(error.message || 'Mesaj g√∂nderilemedi');
      
      // Limit hatasƒ± varsa limit bilgisini g√ºncelle
      if (error.message && error.message.includes('limit')) {
        await refreshMessageLimit();
      }
      
      return false;
    }
  };

  // √ñzel mesaj g√∂nder
  const sendPrivateMessage = async (content: string, receiverId: number): Promise<boolean> => {
    try {
      setError(null);
      
      const response = await chatApi.sendPrivateMessage({ content, receiverId });
      
      // Yeni mesajƒ± aktif chat'e ekle
      if (activeChat && !('chatType' in activeChat)) {
        addNewMessage(response.message);
      }
      
      // √ñzel chat listesini g√ºncelle
      await refreshPrivateChats();
      
      console.log('‚úÖ [CHAT CONTEXT] √ñzel mesaj g√∂nderildi');
      return true;
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] √ñzel mesaj g√∂nderilemedi:', error);
      
      // √ñzel hata mesajlarƒ±
      if (error.message?.includes('Transaction silently rolled back') || 
          error.message?.includes('Mesaj g√∂nderilemedi. L√ºtfen tekrar deneyin.')) {
        setError('Mesaj g√∂nderilemedi. L√ºtfen tekrar deneyin.');
      } else if (error.message?.includes('Sunucu hatasƒ±')) {
        setError('Sunucu hatasƒ±. L√ºtfen daha sonra tekrar deneyin.');
      } else {
        setError(error.message || 'Mesaj g√∂nderilemedi');
      }
      
      return false;
    }
  };

  // Mesaj limiti bilgisini yenile
  const refreshMessageLimit = async () => {
    try {
      const limitInfo = await chatApi.getMessageLimitInfo();
      setMessageLimitInfo(limitInfo);
      
      console.log('‚úÖ [CHAT CONTEXT] Mesaj limiti g√ºncellendi:', {
        canSendMessage: limitInfo.canSendMessage,
        remainingSeconds: limitInfo.remainingSeconds
      });
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Mesaj limiti g√ºncellenemedi:', error);
    }
  };

  // Mesajƒ± deƒüi≈ütir (optimistic update i√ßin)
  const replaceMessage = (oldId: number, newMessage: ChatMessage) => {
    setActiveChat(prevChat => {
      if (!prevChat) return prevChat;
      
      return {
        ...prevChat,
        messages: prevChat.messages.map(msg => 
          msg.id === oldId ? newMessage : msg
        )
      };
    });
    
    console.log('üîÑ [CHAT CONTEXT] Mesaj deƒüi≈ütirildi:', oldId, '->', newMessage.id);
  };

  // Yeni mesaj ekle - Hybrid yakla≈üƒ±m ile iyile≈ütirildi
  const addNewMessage = (message: ChatMessage) => {
    const messageId = message.id.toString();
    
    // Pending mesajlardan kaldƒ±r (WebSocket'ten geldi)
    if (pendingMessagesRef.current.has(messageId)) {
      console.log('‚úÖ [CHAT CONTEXT] Pending mesaj WebSocket\'ten geldi:', messageId);
      setPendingMessages(prev => {
        const newSet = new Set(prev);
        newSet.delete(messageId);
        return newSet;
      });
      pendingMessagesRef.current.delete(messageId);
    }
    
    setActiveChat(prevChat => {
      if (!prevChat || prevChat.chatRoomId !== message.chatRoomId) {
        console.log('‚ö†Ô∏è [CHAT CONTEXT] Mesaj eklenmedi - chat room uyumsuz:', {
          prevChatId: prevChat?.chatRoomId,
          messageRoomId: message.chatRoomId
        });
        return prevChat;
      }
      
      // Mesaj zaten varsa ekleme (hem ID hem de content kontrol√º)
      const messageExists = prevChat.messages.some(m => 
        m.id === message.id || 
        (m.content === message.content && m.sender.id === message.sender.id && 
         Math.abs(new Date(m.sentAt).getTime() - new Date(message.sentAt).getTime()) < 1000)
      );
      
      if (messageExists) {
        console.log('‚ö†Ô∏è [CHAT CONTEXT] Duplicate mesaj engellendi:', message.id);
        return prevChat;
      }
      
      console.log('‚úÖ [CHAT CONTEXT] Yeni mesaj eklendi:', message.id);
      return {
        ...prevChat,
        messages: [message, ...prevChat.messages],
        totalMessages: prevChat.totalMessages + 1
      };
    });
    
    // Chat listesini de g√ºncelle (yeni mesaj geldiƒüinde)
    if (activeChat && !('chatType' in activeChat)) {
      // √ñzel chat i√ßin private chat listesini g√ºncelle
      setPrivateChatList(prevList => 
        prevList.map(chat => 
          chat.id === message.chatRoomId 
            ? {
                ...chat,
                lastMessage: {
                  id: message.id,
                  content: message.content,
                  sentAt: message.sentAt,
                  sender: message.sender
                },
                lastActivity: message.sentAt,
                timeAgo: '≈ûimdi' // Mesaj yeni g√∂nderildiƒüi i√ßin "≈ûimdi" olarak i≈üaretle
              }
            : chat
        )
      );
    } else if (activeChat && 'chatType' in activeChat) {
      // Genel chat i√ßin chat listesini g√ºncelle
      setChatList(prevList => 
        prevList.map(chat => 
          chat.chatRoomId === message.chatRoomId 
            ? {
                ...chat,
                lastMessage: message,
                lastActivity: message.sentAt
              }
            : chat
        )
      );
    }
  };

  // Mesajlarƒ± okundu olarak i≈üaretle
  const markMessagesAsRead = (chatRoomId: number) => {
    // Chat listesinde unread count'u sƒ±fƒ±rla
    setChatList(prevList => 
      prevList.map(chat => 
        chat.chatRoomId === chatRoomId 
          ? { ...chat, unreadCount: 0 }
          : chat
      )
    );
    
    console.log('‚úÖ [CHAT CONTEXT] Mesajlar okundu olarak i≈üaretlendi:', chatRoomId);
  };

  // Zaman formatla
  const formatTimeAgo = (dateString: string) => {
    try {
      const now = new Date();
      const messageTime = new Date(dateString);
      
      if (isNaN(messageTime.getTime())) {
        console.warn('‚ö†Ô∏è [CHAT CONTEXT] Invalid date:', dateString);
        return '≈ûimdi';
      }
      
      const diffMs = now.getTime() - messageTime.getTime();
      const diffMins = Math.floor(diffMs / (1000 * 60));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

      if (diffMins < 1) return '≈ûimdi';
      if (diffMins < 60) return `${diffMins}dk`;
      if (diffHours < 24) return `${diffHours}s`;
      if (diffDays < 7) return `${diffDays}g`;
      
      return messageTime.toLocaleDateString('tr-TR', { 
        day: '2-digit', 
        month: '2-digit' 
      });
    } catch (error) {
      console.error('‚ùå [CHAT CONTEXT] Date format hatasƒ±:', error, dateString);
      return '≈ûimdi';
    }
  };

  // Hata temizle
  const clearError = () => {
    setError(null);
  };

  // WebSocket fonksiyonlarƒ±
  const joinChatRoom = (chatRoomId: string) => {
    if (wsClientRef.current) {
      wsClientRef.current.joinChat(chatRoomId);
      console.log('üë• [CHAT CONTEXT] Chat odasƒ±na katƒ±lƒ±ndƒ±:', chatRoomId);
    }
  };

  const leaveChatRoom = (chatRoomId: string) => {
    if (wsClientRef.current) {
      wsClientRef.current.leaveChat(chatRoomId);
      console.log('üëã [CHAT CONTEXT] Chat odasƒ±ndan √ßƒ±kƒ±ldƒ±:', chatRoomId);
    }
  };

  const sendTypingIndicator = (chatRoomId: string, isTyping: boolean) => {
    if (wsClientRef.current) {
      wsClientRef.current.sendTypingIndicator(chatRoomId, isTyping);
    }
  };

  const updateMessageStatus = (messageId: string, chatRoomId: string, status: 'DELIVERED' | 'READ') => {
    if (wsClientRef.current) {
      wsClientRef.current.updateMessageStatus(messageId, chatRoomId, status);
    }
  };

  // Zorla mesaj yenileme (fallback mekanizmasƒ±)
  const forceRefreshMessages = async () => {
    if (!activeChat || !activeChatId) {
      console.log('‚ö†Ô∏è [CHAT CONTEXT] Aktif chat yok, refresh yapƒ±lamƒ±yor');
      return;
    }
    
    const now = Date.now();
    if (now - lastMessageCheckRef.current < 2000) {
      console.log('‚è∞ [CHAT CONTEXT] √áok sƒ±k refresh, bekleniyor...');
      return;
    }
    
    lastMessageCheckRef.current = now;
    
    try {
      console.log('üîÑ [CHAT CONTEXT] Mesajlar zorla yenileniyor...');
      
      if ('chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
        const newChatData = await chatApi.getGlobalMessages(0, 20);
        setActiveChat(newChatData);
        
        // Limit bilgisini de g√ºncelle
        if (newChatData.userMessageLimit) {
          setMessageLimitInfo(newChatData.userMessageLimit);
        }
      } else {
        const newChatData = await chatApi.getPrivateMessages(activeChatId, 0, 20);
        setActiveChat(newChatData);
      }
      
      console.log('‚úÖ [CHAT CONTEXT] Mesajlar yenilendi');
    } catch (error) {
      console.error('‚ùå [CHAT CONTEXT] Mesaj yenileme hatasƒ±:', error);
    }
  };

  // WebSocket event handler'larƒ± - Hybrid yakla≈üƒ±m ile g√ºncellendi
  const setupWebSocketHandlers = (client: VybeWebSocketClient) => {
    client.setEventHandlers({
      onMessageReceived: (message: WebSocketMessage) => {
        console.log('üì• [CHAT CONTEXT] WebSocket mesaj alƒ±ndƒ±:', message.action);
        
        if (message.action === WebSocketMessageType.MESSAGE_RECEIVED && message.data) {
          const chatMessage = message.data as ChatMessage;
          addNewMessage(chatMessage);
          
          // Pending mesajlardan √ßƒ±kar (eƒüer varsa)
          if (pendingMessagesRef.current.has(chatMessage.id.toString())) {
            console.log('‚úÖ [CHAT CONTEXT] Pending mesaj WebSocket ile alƒ±ndƒ±:', chatMessage.id);
            pendingMessagesRef.current.delete(chatMessage.id.toString());
          }
        }
      },
      
      onMessageDelivered: (messageId: string, chatRoomId: string) => {
        console.log('‚úÖ [CHAT CONTEXT] Mesaj iletildi:', messageId, chatRoomId);
        // Mesaj durumunu g√ºncelle
        setActiveChat(prevChat => {
          if (!prevChat) return prevChat;
          
          return {
            ...prevChat,
            messages: prevChat.messages.map(msg => 
              msg.id.toString() === messageId ? { ...msg, status: 'DELIVERED' as const } : msg
            )
          };
        });
      },
      
      onMessageRead: (messageId: string, chatRoomId: string) => {
        console.log('üëÅÔ∏è [CHAT CONTEXT] Mesaj okundu:', messageId, chatRoomId);
        // Mesaj durumunu g√ºncelle
        setActiveChat(prevChat => {
          if (!prevChat) return prevChat;
          
          return {
            ...prevChat,
            messages: prevChat.messages.map(msg => 
              msg.id.toString() === messageId ? { ...msg, status: 'READ' as const } : msg
            )
          };
        });
      },
      
      onTypingStart: (userId: string, chatRoomId: string, userName: string) => {
        console.log('‚å®Ô∏è [CHAT CONTEXT] Yazƒ±yor:', userName, chatRoomId);
        
        setTypingUsers(prev => {
          const newMap = new Map(prev);
          const chatUsers = new Set(newMap.get(chatRoomId) || []);
          chatUsers.add(userId);
          newMap.set(chatRoomId, chatUsers);
          return newMap;
        });
      },
      
      onTypingStop: (userId: string, chatRoomId: string) => {
        console.log('‚èπÔ∏è [CHAT CONTEXT] Yazmayƒ± durdurdu:', userId, chatRoomId);
        
        setTypingUsers(prev => {
          const newMap = new Map(prev);
          const chatUsers = new Set(newMap.get(chatRoomId) || []);
          chatUsers.delete(userId);
          if (chatUsers.size === 0) {
            newMap.delete(chatRoomId);
          } else {
            newMap.set(chatRoomId, chatUsers);
          }
          return newMap;
        });
      },
      
      onUserOnline: (userId: string) => {
        console.log('üü¢ [CHAT CONTEXT] Kullanƒ±cƒ± online:', userId);
        // Private chat listesinde kullanƒ±cƒ±yƒ± online yap
        setPrivateChatList(prev => 
          prev.map(chat => 
            chat.otherUser.id.toString() === userId 
              ? { ...chat, otherUser: { ...chat.otherUser, isOnline: true } }
              : chat
          )
        );
      },
      
      onUserOffline: (userId: string) => {
        console.log('üî¥ [CHAT CONTEXT] Kullanƒ±cƒ± offline:', userId);
        // Private chat listesinde kullanƒ±cƒ±yƒ± offline yap
        setPrivateChatList(prev => 
          prev.map(chat => 
            chat.otherUser.id.toString() === userId 
              ? { ...chat, otherUser: { ...chat.otherUser, isOnline: false } }
              : chat
          )
        );
      },
      
      onConnected: () => {
        console.log('‚úÖ [CHAT CONTEXT] WebSocket baƒülandƒ±');
        setWsStatus(WebSocketStatus.CONNECTED);
        setIsWebSocketConnected(true);
        
        // Baƒülantƒ± kurulduƒüunda pending mesajlarƒ± kontrol et
        if (pendingMessagesRef.current.size > 0) {
          console.log('üîÑ [CHAT CONTEXT] WebSocket baƒülandƒ±, pending mesajlar kontrol ediliyor...');
          setTimeout(() => forceRefreshMessages(), 2000);
        }
      },
      
      onDisconnected: () => {
        console.log('üîå [CHAT CONTEXT] WebSocket baƒülantƒ±sƒ± kesildi');
        setWsStatus(WebSocketStatus.DISCONNECTED);
        setIsWebSocketConnected(false);
        
        // Baƒülantƒ± koptuƒüunda pending mesajlar i√ßin polling ba≈ülat
        if (pendingMessagesRef.current.size > 0) {
          console.log('üîÑ [CHAT CONTEXT] WebSocket koptu, polling ba≈ülatƒ±lƒ±yor...');
          setTimeout(() => forceRefreshMessages(), 1000);
        }
      },
      
      onError: (error: string) => {
        console.error('‚ùå [CHAT CONTEXT] WebSocket hatasƒ±:', error);
        setWsStatus(WebSocketStatus.ERROR);
        setIsWebSocketConnected(false);
        setError(`WebSocket hatasƒ±: ${error}`);
        
        // Hata durumunda da polling ba≈ülat
        if (pendingMessagesRef.current.size > 0) {
          setTimeout(() => forceRefreshMessages(), 1000);
        }
      }
    });
  };

  // WebSocket ba≈ülatma
  const initializeWebSocketConnection = async () => {
    try {
      const token = await getToken();
      if (!token) {
        console.warn('‚ö†Ô∏è [CHAT CONTEXT] Token bulunamadƒ±, WebSocket ba≈ülatƒ±lamƒ±yor');
        return;
      }

      // Kullanƒ±cƒ± bilgisini al
      let userId: string;
      try {
        const userProfile = await userApi.getProfile();
        userId = userProfile.id.toString();
        console.log('üë§ [CHAT CONTEXT] Kullanƒ±cƒ± ID alƒ±ndƒ±:', userId);
      } catch (error) {
        console.warn('‚ö†Ô∏è [CHAT CONTEXT] Kullanƒ±cƒ± bilgisi alƒ±namadƒ±, token yenileme bekleniyor:', error);
        // Token yenileme s√ºrecinde olduƒüu i√ßin 3 saniye sonra tekrar dene
        setTimeout(() => {
          console.log('üîÑ [CHAT CONTEXT] WebSocket ba≈ülatma tekrar deneniyor...');
          initializeWebSocketConnection();
        }, 3000);
        return;
      }

      console.log('üîå [CHAT CONTEXT] WebSocket baƒülantƒ±sƒ± ba≈ülatƒ±lƒ±yor...');
      setWsStatus(WebSocketStatus.CONNECTING);
      
      const client = await initializeWebSocket(token, userId);
      wsClientRef.current = client;
      setWsClient(client);
      
      setupWebSocketHandlers(client);
      
      console.log('‚úÖ [CHAT CONTEXT] WebSocket baƒülantƒ±sƒ± ba≈üarƒ±lƒ±');
    } catch (error) {
      console.error('‚ùå [CHAT CONTEXT] WebSocket ba≈ülatma hatasƒ±:', error);
      setWsStatus(WebSocketStatus.ERROR);
      setError('WebSocket baƒülantƒ±sƒ± kurulamadƒ±');
    }
  };

  // Component mount olduƒüunda chat listesini ve limit bilgisini y√ºkle
  useEffect(() => {
    refreshChatList();
    refreshPrivateChats();
    refreshMessageLimit();
    initializeWebSocketConnection();
  }, []);

  // Component unmount olduƒüunda WebSocket'i kapat
  useEffect(() => {
    return () => {
      if (wsClientRef.current) {
        wsClientRef.current.disconnect();
      }
    };
  }, []);

  // Polling'i tamamen devre dƒ±≈üƒ± bƒ±rak - sadece WebSocket kullan
  // useEffect(() => {
  //   console.log('üîå [CHAT CONTEXT] Polling devre dƒ±≈üƒ± - sadece WebSocket kullanƒ±lƒ±yor');
  // }, []);

  // Mesaj limiti countdown'u i√ßin interval
  useEffect(() => {
    if (!messageLimitInfo || messageLimitInfo.canSendMessage || messageLimitInfo.remainingSeconds <= 0) {
      return;
    }

    const interval = setInterval(() => {
      setMessageLimitInfo(prevLimit => {
        if (!prevLimit || prevLimit.remainingSeconds <= 0) {
          return prevLimit;
        }

        const newRemainingSeconds = prevLimit.remainingSeconds - 1;
        
        if (newRemainingSeconds <= 0) {
          // Limit doldu, yeniden kontrol et
          refreshMessageLimit();
          return prevLimit;
        }

        // Countdown mesajƒ±nƒ± g√ºncelle
        const minutes = Math.floor(newRemainingSeconds / 60);
        const seconds = newRemainingSeconds % 60;
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        return {
          ...prevLimit,
          remainingSeconds: newRemainingSeconds,
          message: `Sonraki mesaj: ${timeString}`
        };
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [messageLimitInfo]);

  // Hata g√∂sterimi
  useEffect(() => {
    if (error) {
      Alert.alert('Hata', error, [
        { text: 'Tamam', onPress: clearError }
      ]);
    }
  }, [error]);

  return (
    <ChatContext.Provider
      value={{
        chatList,
        isLoadingChatList,
        refreshChatList,
        privateChatList,
        isLoadingPrivateChats,
        refreshPrivateChats,
        activeChat,
        activeChatId,
        isLoadingMessages,
        sendGlobalMessage,
        sendPrivateMessage,
        loadMessages,
        loadMoreMessages,
        messageLimitInfo,
        refreshMessageLimit,
        addNewMessage,
        replaceMessage,
        markMessagesAsRead,
        isTyping,
        setIsTyping,
        setFastPolling,
        wsStatus,
        wsClient,
        joinChatRoom,
        leaveChatRoom,
        sendTypingIndicator,
        updateMessageStatus,
        typingUsers,
        error,
        clearError,
        // Hybrid yakla≈üƒ±m i√ßin yeni √∂zellikler
        isWebSocketConnected,
        pendingMessages,
        forceRefreshMessages
      }}
    >
      {children}
    </ChatContext.Provider>
  );
}

// Context'i kullanmak i√ßin hook
export function useChat() {
  const context = useContext(ChatContext);
  if (context === undefined) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
}
