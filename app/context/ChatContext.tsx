import React, { createContext, ReactNode, useContext, useEffect, useRef, useState } from 'react';
import { Alert } from 'react-native';
import { chatApi, ChatListItem, ChatMessage, GlobalChatResponse, MessageLimitInfo, PrivateChatResponse, PrivateChatRoom } from '../services/api';
import {
    initializeWebSocket,
    VybeWebSocketClient,
    WebSocketMessage,
    WebSocketMessageType,
    WebSocketStatus
} from '../services/websocket';
import { getToken } from '../utils/tokenStorage';

// Context deƒüer tipi
type ChatContextType = {
  // Chat listesi
  chatList: ChatListItem[];
  isLoadingChatList: boolean;
  refreshChatList: () => Promise<void>;
  
  // Private chat listesi
  privateChatList: PrivateChatRoom[];
  isLoadingPrivateChats: boolean;
  refreshPrivateChats: () => Promise<void>;
  
  // Aktif chat
  activeChat: GlobalChatResponse | PrivateChatResponse | null;
  activeChatId: number | null;
  isLoadingMessages: boolean;
  
  // Mesaj i≈ülemleri
  sendGlobalMessage: (content: string) => Promise<boolean>;
  sendPrivateMessage: (content: string, receiverId: number) => Promise<boolean>;
  loadMessages: (chatRoomId: number, chatType: 'GLOBAL' | 'PRIVATE') => Promise<void>;
  loadMoreMessages: () => Promise<void>;
  
  // Mesaj limiti
  messageLimitInfo: MessageLimitInfo | null;
  refreshMessageLimit: () => Promise<void>;
  
  // Real-time g√ºncelleme
  addNewMessage: (message: ChatMessage) => void;
  markMessagesAsRead: (chatRoomId: number) => void;
  
  // UI durumu
  isTyping: boolean;
  setIsTyping: (typing: boolean) => void;
  
  // Real-time polling kontrol√º
  setFastPolling: (enabled: boolean) => void;
  
  // WebSocket durumu
  wsStatus: WebSocketStatus;
  wsClient: VybeWebSocketClient | null;
  
  // WebSocket i≈ülemleri
  joinChatRoom: (chatRoomId: number) => void;
  leaveChatRoom: (chatRoomId: number) => void;
  sendTypingIndicator: (chatRoomId: number, isTyping: boolean) => void;
  updateMessageStatus: (messageId: number, chatRoomId: number, status: 'DELIVERED' | 'READ') => void;
  
  // Typing indicator'lar
  typingUsers: Map<number, Set<number>>; // chatRoomId -> Set<userId>
  
  // Hata y√∂netimi
  error: string | null;
  clearError: () => void;
};

// Context olu≈ütur
const ChatContext = createContext<ChatContextType | undefined>(undefined);

// Context Provider bile≈üeni
export function ChatProvider({ children }: { children: ReactNode }) {
  // State'ler
  const [chatList, setChatList] = useState<ChatListItem[]>([]);
  const [isLoadingChatList, setIsLoadingChatList] = useState(false);
  const [privateChatList, setPrivateChatList] = useState<PrivateChatRoom[]>([]);
  const [isLoadingPrivateChats, setIsLoadingPrivateChats] = useState(false);
  
  const [activeChat, setActiveChat] = useState<GlobalChatResponse | PrivateChatResponse | null>(null);
  const [activeChatId, setActiveChatId] = useState<number | null>(null);
  const [isLoadingMessages, setIsLoadingMessages] = useState(false);
  
  const [messageLimitInfo, setMessageLimitInfo] = useState<MessageLimitInfo | null>(null);
  const [isTyping, setIsTyping] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [fastPolling, setFastPolling] = useState(false);
  
  // WebSocket state'leri
  const [wsStatus, setWsStatus] = useState<WebSocketStatus>(WebSocketStatus.DISCONNECTED);
  const [wsClient, setWsClient] = useState<VybeWebSocketClient | null>(null);
  const [typingUsers, setTypingUsers] = useState<Map<number, Set<number>>>(new Map());
  
  // Ref'ler
  const wsClientRef = useRef<VybeWebSocketClient | null>(null);
  const typingUsersRef = useRef<Map<number, Set<number>>>(new Map());

  // Chat listesini y√ºkle
  const refreshChatList = async () => {
    try {
      setIsLoadingChatList(true);
      setError(null);
      
      const chatListData = await chatApi.getChatList();
      setChatList(chatListData);
      
      console.log('‚úÖ [CHAT CONTEXT] Chat listesi y√ºklendi:', chatListData.length);
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Chat listesi y√ºklenemedi:', error);
      setError('Chat listesi y√ºklenemedi');
    } finally {
      setIsLoadingChatList(false);
    }
  };

  // Private chat listesini yenile
  const refreshPrivateChats = async () => {
    try {
      setIsLoadingPrivateChats(true);
      console.log('üîÑ [CHAT CONTEXT] Private chat listesi yenileniyor...');
      
      const privateChatData = await chatApi.getPrivateChatList();
      setPrivateChatList(privateChatData.privateChatRooms);
      
      console.log('‚úÖ [CHAT CONTEXT] Private chat listesi y√ºklendi:', privateChatData.privateChatRooms.length);
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Private chat listesi y√ºklenemedi:', error);
      
      // Oturum problemi varsa kullanƒ±cƒ±yƒ± bilgilendir
      if (error.message?.includes('Oturum bilgilerinizde bir sorun var') || 
          error.message?.includes('Oturum s√ºresi dolmu≈ü')) {
        setError(error.message);
      } else {
        // Diƒüer hatalar i√ßin sessizce ge√ß, kritik deƒüil
        console.log('‚ÑπÔ∏è [CHAT CONTEXT] Private chat hatasƒ± g√∂rmezden geliniyor');
      }
    } finally {
      setIsLoadingPrivateChats(false);
    }
  };

  // Mesajlarƒ± y√ºkle
  const loadMessages = async (chatRoomId: number, chatType: 'GLOBAL' | 'PRIVATE') => {
    try {
      setIsLoadingMessages(true);
      setError(null);
      setActiveChatId(chatRoomId);
      
      let chatData: GlobalChatResponse | PrivateChatResponse;
      
      if (chatType === 'GLOBAL') {
        chatData = await chatApi.getGlobalMessages(0, 20);
        
        // Global chat i√ßin limit bilgisini de g√ºncelle
        if (chatData.userMessageLimit) {
          setMessageLimitInfo(chatData.userMessageLimit);
          console.log('‚úÖ [CHAT CONTEXT] Global chat limit bilgisi g√ºncellendi:', chatData.userMessageLimit);
        }
      } else {
        chatData = await chatApi.getPrivateMessages(chatRoomId, 0, 20);
        
        // Private chat i√ßin otherUser kontrol√º
        if (!('chatType' in chatData) && (!chatData.otherUser || !chatData.otherUser.id)) {
          console.error('‚ùå [CHAT CONTEXT] Private chat otherUser eksik:', {
            hasOtherUser: !!chatData.otherUser,
            otherUserId: chatData.otherUser?.id,
            chatData: chatData
          });
          
          // Chat listesinden otherUser bilgisini almaya √ßalƒ±≈ü
          console.log('üîÑ [CHAT CONTEXT] Chat listesinden otherUser almaya √ßalƒ±≈üƒ±lƒ±yor...');
          try {
            await refreshPrivateChats();
            const chatRoom = privateChatList.find(chat => chat.id === chatRoomId);
            
            if (chatRoom && chatRoom.otherUser) {
              console.log('‚úÖ [CHAT CONTEXT] Chat listesinden otherUser bulundu:', chatRoom.otherUser);
              chatData.otherUser = chatRoom.otherUser;
            } else {
              console.error('‚ùå [CHAT CONTEXT] Chat listesinde de otherUser bulunamadƒ±');
              throw new Error('Sohbet bilgileri eksik. L√ºtfen tekrar deneyin.');
            }
          } catch (fallbackError) {
            console.error('‚ùå [CHAT CONTEXT] Fallback otherUser alma hatasƒ±:', fallbackError);
            throw new Error('Sohbet bilgileri eksik. L√ºtfen tekrar deneyin.');
          }
        }
      }
      
      setActiveChat(chatData);
      
      console.log('‚úÖ [CHAT CONTEXT] Mesajlar y√ºklendi:', {
        chatRoomId,
        chatType,
        messageCount: chatData.messages.length
      });
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Mesajlar y√ºklenemedi:', error);
      
      // √ñzel hata mesajlarƒ±
      if (error.message?.includes('Sohbet bilgileri eksik')) {
        setError('Sohbet bilgileri eksik. Sayfayƒ± yenileyin.');
      } else {
        setError('Mesajlar y√ºklenemedi');
      }
    } finally {
      setIsLoadingMessages(false);
    }
  };

  // Daha fazla mesaj y√ºkle (pagination)
  const loadMoreMessages = async () => {
    if (!activeChat || !activeChatId || isLoadingMessages || !activeChat.hasMore) {
      return;
    }

    try {
      setIsLoadingMessages(true);
      
      const nextPage = activeChat.currentPage + 1;
      let newChatData: GlobalChatResponse | PrivateChatResponse;
      
      if ('chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
        newChatData = await chatApi.getGlobalMessages(nextPage, 20);
      } else {
        newChatData = await chatApi.getPrivateMessages(activeChatId, nextPage, 20);
      }
      
      // Mevcut mesajlarƒ± yeni mesajlarla birle≈ütir
      setActiveChat(prevChat => {
        if (!prevChat) return newChatData;
        
        return {
          ...prevChat,
          messages: [...prevChat.messages, ...newChatData.messages],
          currentPage: newChatData.currentPage,
          hasMore: newChatData.hasMore
        };
      });
      
      console.log('‚úÖ [CHAT CONTEXT] Daha fazla mesaj y√ºklendi:', newChatData.messages.length);
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Daha fazla mesaj y√ºklenemedi:', error);
    } finally {
      setIsLoadingMessages(false);
    }
  };

  // Genel chat'e mesaj g√∂nder
  const sendGlobalMessage = async (content: string): Promise<boolean> => {
    console.log('üîÑ [CHAT CONTEXT] sendGlobalMessage ba≈ülatƒ±ldƒ±:', {
      content: content.substring(0, 50),
      activeChat: activeChat ? 'var' : 'yok',
      chatType: activeChat && 'chatType' in activeChat ? activeChat.chatType : 'bilinmiyor'
    });
    
    try {
      setError(null);
      
      const response = await chatApi.sendGlobalMessage({ content });
      console.log('‚úÖ [CHAT CONTEXT] API yanƒ±tƒ± alƒ±ndƒ±:', response.message.id);
      
      // Yeni mesajƒ± aktif chat'e ekle
      if (activeChat && 'chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
        console.log('‚úÖ [CHAT CONTEXT] Mesaj aktif chat\'e ekleniyor');
        addNewMessage(response.message);
      } else {
        console.warn('‚ö†Ô∏è [CHAT CONTEXT] Aktif chat global deƒüil veya yok:', {
          hasActiveChat: !!activeChat,
          hasChatType: activeChat && 'chatType' in activeChat,
          chatType: activeChat && 'chatType' in activeChat ? activeChat.chatType : null
        });
      }
      
      // Chat listesini g√ºncelle (sadece mesaj eklenmediƒüinde)
      if (!activeChat || !('chatType' in activeChat) || activeChat.chatType !== 'GLOBAL') {
        await refreshChatList();
      }
      
      console.log('‚úÖ [CHAT CONTEXT] Genel mesaj g√∂nderildi');
      
      // Mesaj g√∂nderildikten sonra 10 saniye boyunca √ßok hƒ±zlƒ± polling (500ms)
      const originalFastPolling = fastPolling;
      setFastPolling(true);
      
      // 500ms'lik s√ºper hƒ±zlƒ± polling i√ßin ge√ßici interval
      const superFastInterval = setInterval(async () => {
        try {
          if (activeChat && 'chatType' in activeChat && activeChat.chatType === 'GLOBAL') {
            const newChatData = await chatApi.getGlobalMessages(0, 5);
            const currentMessageIds = activeChat.messages.map(m => m.id);
            const newMessages = newChatData.messages.filter(m => !currentMessageIds.includes(m.id));
            
            if (newMessages.length > 0) {
              console.log(`‚ö° [CHAT CONTEXT] S√ºper hƒ±zlƒ± polling - ${newMessages.length} yeni mesaj`);
              newMessages.reverse().forEach(message => {
                addNewMessage(message);
              });
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [CHAT CONTEXT] S√ºper hƒ±zlƒ± polling hatasƒ±:', error);
        }
      }, 500);
      
      // 10 saniye sonra normal polling'e d√∂n
      setTimeout(() => {
        clearInterval(superFastInterval);
        setFastPolling(originalFastPolling);
        console.log('‚è∏Ô∏è [CHAT CONTEXT] S√ºper hƒ±zlƒ± polling durduruldu');
      }, 10000);
      
      return true;
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Genel mesaj g√∂nderilemedi:', error);
      setError(error.message || 'Mesaj g√∂nderilemedi');
      
      // Limit hatasƒ± varsa limit bilgisini g√ºncelle
      if (error.message && error.message.includes('limit')) {
        await refreshMessageLimit();
      }
      
      return false;
    }
  };

  // √ñzel mesaj g√∂nder
  const sendPrivateMessage = async (content: string, receiverId: number): Promise<boolean> => {
    try {
      setError(null);
      
      const response = await chatApi.sendPrivateMessage({ content, receiverId });
      
      // Yeni mesajƒ± aktif chat'e ekle
      if (activeChat && !('chatType' in activeChat)) {
        addNewMessage(response.message);
      }
      
      // √ñzel chat listesini g√ºncelle
      await refreshPrivateChats();
      
      console.log('‚úÖ [CHAT CONTEXT] √ñzel mesaj g√∂nderildi');
      return true;
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] √ñzel mesaj g√∂nderilemedi:', error);
      
      // √ñzel hata mesajlarƒ±
      if (error.message?.includes('Transaction silently rolled back') || 
          error.message?.includes('Mesaj g√∂nderilemedi. L√ºtfen tekrar deneyin.')) {
        setError('Mesaj g√∂nderilemedi. L√ºtfen tekrar deneyin.');
      } else if (error.message?.includes('Sunucu hatasƒ±')) {
        setError('Sunucu hatasƒ±. L√ºtfen daha sonra tekrar deneyin.');
      } else {
        setError(error.message || 'Mesaj g√∂nderilemedi');
      }
      
      return false;
    }
  };

  // Mesaj limiti bilgisini yenile
  const refreshMessageLimit = async () => {
    try {
      const limitInfo = await chatApi.getMessageLimitInfo();
      setMessageLimitInfo(limitInfo);
      
      console.log('‚úÖ [CHAT CONTEXT] Mesaj limiti g√ºncellendi:', {
        canSendMessage: limitInfo.canSendMessage,
        remainingSeconds: limitInfo.remainingSeconds
      });
    } catch (error: any) {
      console.error('‚ùå [CHAT CONTEXT] Mesaj limiti g√ºncellenemedi:', error);
    }
  };

  // Yeni mesaj ekle (real-time i√ßin)
  const addNewMessage = (message: ChatMessage) => {
    setActiveChat(prevChat => {
      if (!prevChat || prevChat.chatRoomId !== message.chatRoomId) {
        console.log('‚ö†Ô∏è [CHAT CONTEXT] Mesaj eklenmedi - chat room uyumsuz:', {
          prevChatId: prevChat?.chatRoomId,
          messageRoomId: message.chatRoomId
        });
        return prevChat;
      }
      
      // Mesaj zaten varsa ekleme (hem ID hem de content kontrol√º)
      const messageExists = prevChat.messages.some(m => 
        m.id === message.id || 
        (m.content === message.content && m.sender.id === message.sender.id && 
         Math.abs(new Date(m.sentAt).getTime() - new Date(message.sentAt).getTime()) < 1000)
      );
      
      if (messageExists) {
        console.log('‚ö†Ô∏è [CHAT CONTEXT] Duplicate mesaj engellendi:', message.id);
        return prevChat;
      }
      
      console.log('‚úÖ [CHAT CONTEXT] Yeni mesaj eklendi:', message.id);
      return {
        ...prevChat,
        messages: [message, ...prevChat.messages],
        totalMessages: prevChat.totalMessages + 1
      };
    });
    
    // Chat listesini de g√ºncelle (yeni mesaj geldiƒüinde)
    if (activeChat && !('chatType' in activeChat)) {
      // √ñzel chat i√ßin private chat listesini g√ºncelle
      setPrivateChatList(prevList => 
        prevList.map(chat => 
          chat.id === message.chatRoomId 
            ? {
                ...chat,
                lastMessage: {
                  id: message.id,
                  content: message.content,
                  sentAt: message.sentAt,
                  sender: message.sender
                },
                lastActivity: message.sentAt,
                timeAgo: '≈ûimdi' // Mesaj yeni g√∂nderildiƒüi i√ßin "≈ûimdi" olarak i≈üaretle
              }
            : chat
        )
      );
    } else if (activeChat && 'chatType' in activeChat) {
      // Genel chat i√ßin chat listesini g√ºncelle
      setChatList(prevList => 
        prevList.map(chat => 
          chat.chatRoomId === message.chatRoomId 
            ? {
                ...chat,
                lastMessage: message,
                lastActivity: message.sentAt
              }
            : chat
        )
      );
    }
  };

  // Mesajlarƒ± okundu olarak i≈üaretle
  const markMessagesAsRead = (chatRoomId: number) => {
    // Chat listesinde unread count'u sƒ±fƒ±rla
    setChatList(prevList => 
      prevList.map(chat => 
        chat.chatRoomId === chatRoomId 
          ? { ...chat, unreadCount: 0 }
          : chat
      )
    );
    
    console.log('‚úÖ [CHAT CONTEXT] Mesajlar okundu olarak i≈üaretlendi:', chatRoomId);
  };

  // Zaman formatla
  const formatTimeAgo = (dateString: string) => {
    try {
      const now = new Date();
      const messageTime = new Date(dateString);
      
      if (isNaN(messageTime.getTime())) {
        console.warn('‚ö†Ô∏è [CHAT CONTEXT] Invalid date:', dateString);
        return '≈ûimdi';
      }
      
      const diffMs = now.getTime() - messageTime.getTime();
      const diffMins = Math.floor(diffMs / (1000 * 60));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

      if (diffMins < 1) return '≈ûimdi';
      if (diffMins < 60) return `${diffMins}dk`;
      if (diffHours < 24) return `${diffHours}s`;
      if (diffDays < 7) return `${diffDays}g`;
      
      return messageTime.toLocaleDateString('tr-TR', { 
        day: '2-digit', 
        month: '2-digit' 
      });
    } catch (error) {
      console.error('‚ùå [CHAT CONTEXT] Date format hatasƒ±:', error, dateString);
      return '≈ûimdi';
    }
  };

  // Hata temizle
  const clearError = () => {
    setError(null);
  };

  // WebSocket fonksiyonlarƒ±
  const joinChatRoom = (chatRoomId: number) => {
    if (wsClientRef.current) {
      wsClientRef.current.joinChat(chatRoomId);
      console.log('üë• [CHAT CONTEXT] Chat odasƒ±na katƒ±lƒ±ndƒ±:', chatRoomId);
    }
  };

  const leaveChatRoom = (chatRoomId: number) => {
    if (wsClientRef.current) {
      wsClientRef.current.leaveChat(chatRoomId);
      console.log('üëã [CHAT CONTEXT] Chat odasƒ±ndan √ßƒ±kƒ±ldƒ±:', chatRoomId);
    }
  };

  const sendTypingIndicator = (chatRoomId: number, isTyping: boolean) => {
    if (wsClientRef.current) {
      wsClientRef.current.sendTypingIndicator(chatRoomId, isTyping);
    }
  };

  const updateMessageStatus = (messageId: number, chatRoomId: number, status: 'DELIVERED' | 'READ') => {
    if (wsClientRef.current) {
      wsClientRef.current.updateMessageStatus(messageId, chatRoomId, status);
    }
  };

  // WebSocket event handler'larƒ±
  const setupWebSocketHandlers = (client: VybeWebSocketClient) => {
    client.setEventHandlers({
      onMessageReceived: (message: WebSocketMessage) => {
        console.log('üì• [CHAT CONTEXT] WebSocket mesaj alƒ±ndƒ±:', message.type);
        
        if (message.type === WebSocketMessageType.MESSAGE_RECEIVED && message.data) {
          const chatMessage = message.data as ChatMessage;
          addNewMessage(chatMessage);
        }
      },
      
      onMessageDelivered: (messageId: number, chatRoomId: number) => {
        console.log('‚úÖ [CHAT CONTEXT] Mesaj iletildi:', messageId, chatRoomId);
        // Mesaj durumunu g√ºncelle
        setActiveChat(prevChat => {
          if (!prevChat) return prevChat;
          
          return {
            ...prevChat,
            messages: prevChat.messages.map(msg => 
              msg.id === messageId ? { ...msg, status: 'DELIVERED' as const } : msg
            )
          };
        });
      },
      
      onMessageRead: (messageId: number, chatRoomId: number) => {
        console.log('üëÅÔ∏è [CHAT CONTEXT] Mesaj okundu:', messageId, chatRoomId);
        // Mesaj durumunu g√ºncelle
        setActiveChat(prevChat => {
          if (!prevChat) return prevChat;
          
          return {
            ...prevChat,
            messages: prevChat.messages.map(msg => 
              msg.id === messageId ? { ...msg, status: 'READ' as const } : msg
            )
          };
        });
      },
      
      onTypingStart: (userId: number, chatRoomId: number, userName: string) => {
        console.log('‚å®Ô∏è [CHAT CONTEXT] Yazƒ±yor:', userName, chatRoomId);
        
        setTypingUsers(prev => {
          const newMap = new Map(prev);
          const chatUsers = new Set(newMap.get(chatRoomId) || []);
          chatUsers.add(userId);
          newMap.set(chatRoomId, chatUsers);
          return newMap;
        });
      },
      
      onTypingStop: (userId: number, chatRoomId: number) => {
        console.log('‚èπÔ∏è [CHAT CONTEXT] Yazmayƒ± durdurdu:', userId, chatRoomId);
        
        setTypingUsers(prev => {
          const newMap = new Map(prev);
          const chatUsers = new Set(newMap.get(chatRoomId) || []);
          chatUsers.delete(userId);
          if (chatUsers.size === 0) {
            newMap.delete(chatRoomId);
          } else {
            newMap.set(chatRoomId, chatUsers);
          }
          return newMap;
        });
      },
      
      onUserOnline: (userId: number) => {
        console.log('üü¢ [CHAT CONTEXT] Kullanƒ±cƒ± online:', userId);
        // Private chat listesinde kullanƒ±cƒ±yƒ± online yap
        setPrivateChatList(prev => 
          prev.map(chat => 
            chat.otherUser.id === userId 
              ? { ...chat, otherUser: { ...chat.otherUser, isOnline: true } }
              : chat
          )
        );
      },
      
      onUserOffline: (userId: number) => {
        console.log('üî¥ [CHAT CONTEXT] Kullanƒ±cƒ± offline:', userId);
        // Private chat listesinde kullanƒ±cƒ±yƒ± offline yap
        setPrivateChatList(prev => 
          prev.map(chat => 
            chat.otherUser.id === userId 
              ? { ...chat, otherUser: { ...chat.otherUser, isOnline: false } }
              : chat
          )
        );
      },
      
      onConnected: () => {
        console.log('‚úÖ [CHAT CONTEXT] WebSocket baƒülandƒ±');
        setWsStatus(WebSocketStatus.CONNECTED);
      },
      
      onDisconnected: () => {
        console.log('üîå [CHAT CONTEXT] WebSocket baƒülantƒ±sƒ± kesildi');
        setWsStatus(WebSocketStatus.DISCONNECTED);
      },
      
      onError: (error: string) => {
        console.error('‚ùå [CHAT CONTEXT] WebSocket hatasƒ±:', error);
        setWsStatus(WebSocketStatus.ERROR);
        setError(`WebSocket hatasƒ±: ${error}`);
      }
    });
  };

  // WebSocket ba≈ülatma
  const initializeWebSocketConnection = async () => {
    try {
      const token = await getToken();
      if (!token) {
        console.warn('‚ö†Ô∏è [CHAT CONTEXT] Token bulunamadƒ±, WebSocket ba≈ülatƒ±lamƒ±yor');
        return;
      }

      console.log('üîå [CHAT CONTEXT] WebSocket baƒülantƒ±sƒ± ba≈ülatƒ±lƒ±yor...');
      setWsStatus(WebSocketStatus.CONNECTING);
      
      const client = await initializeWebSocket(token, 'ws://localhost:8080');
      wsClientRef.current = client;
      setWsClient(client);
      
      setupWebSocketHandlers(client);
      
      console.log('‚úÖ [CHAT CONTEXT] WebSocket baƒülantƒ±sƒ± ba≈üarƒ±lƒ±');
    } catch (error) {
      console.error('‚ùå [CHAT CONTEXT] WebSocket ba≈ülatma hatasƒ±:', error);
      setWsStatus(WebSocketStatus.ERROR);
      setError('WebSocket baƒülantƒ±sƒ± kurulamadƒ±');
    }
  };

  // Component mount olduƒüunda chat listesini ve limit bilgisini y√ºkle
  useEffect(() => {
    refreshChatList();
    refreshPrivateChats();
    refreshMessageLimit();
    initializeWebSocketConnection();
  }, []);

  // Component unmount olduƒüunda WebSocket'i kapat
  useEffect(() => {
    return () => {
      if (wsClientRef.current) {
        wsClientRef.current.disconnect();
      }
    };
  }, []);

  // Real-time updates i√ßin hƒ±zlƒ± polling (genel chat i√ßin 2 saniye, √∂zel chat i√ßin 5 saniye)
  useEffect(() => {
    let interval: any;
    
    const startPolling = () => {
      // Aktif chat'e g√∂re polling s√ºresi belirle
      const chatType = activeChat && 'chatType' in activeChat ? 'GLOBAL' : 'PRIVATE';
      let pollingInterval;
      
      if (chatType === 'GLOBAL') {
        // Genel chat i√ßin: hƒ±zlƒ± modda 3 saniye, normal modda 10 saniye
        pollingInterval = fastPolling ? 3000 : 10000;
      } else {
        // √ñzel chat i√ßin: hƒ±zlƒ± modda 5 saniye, normal modda 15 saniye
        pollingInterval = fastPolling ? 5000 : 15000;
      }
      
      interval = setInterval(async () => {
        try {
          // Sadece aktif chat varsa ve ekran g√∂r√ºn√ºrse g√ºncelle
          if (activeChatId && !isLoadingMessages && activeChat) {
            console.log(`üîÑ [CHAT CONTEXT] Real-time g√ºncelleme - ${chatType} (${pollingInterval}ms)`);
            
            let newChatData: GlobalChatResponse | PrivateChatResponse;
            
            if (chatType === 'GLOBAL') {
              newChatData = await chatApi.getGlobalMessages(0, 20);
              
              // Global chat i√ßin aktif kullanƒ±cƒ± sayƒ±sƒ±nƒ± da g√ºncelle
              setActiveChat(prevChat => {
                if (!prevChat || !('activeUserCount' in prevChat)) return prevChat;
                return {
                  ...prevChat,
                  activeUserCount: (newChatData as GlobalChatResponse).activeUserCount
                };
              });
            } else {
              newChatData = await chatApi.getPrivateMessages(activeChatId, 0, 20);
            }
            
            // Yeni mesajlar varsa g√ºncelle
            const currentMessageIds = activeChat.messages.map(m => m.id);
            const newMessages = newChatData.messages.filter(m => !currentMessageIds.includes(m.id));
            
            if (newMessages.length > 0) {
              console.log(`üÜï [CHAT CONTEXT] ${newMessages.length} yeni mesaj bulundu (${chatType})`);
              
              // Yeni mesajlarƒ± tek tek ekle (duplicate kontrol√º ile)
              newMessages.reverse().forEach(message => {
                addNewMessage(message);
              });
              
              // Chat listesini sadece yeni mesaj geldiƒüinde g√ºncelle (daha az sƒ±klƒ±kta)
              if (chatType === 'GLOBAL') {
                // Global chat i√ßin sadece yeni mesaj geldiƒüinde g√ºncelle
                setTimeout(() => refreshChatList(), 1000);
              } else {
                // √ñzel chat i√ßin private chat listesini g√ºncelle
                setTimeout(() => refreshPrivateChats(), 1000);
              }
            }
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è [CHAT CONTEXT] Real-time g√ºncelleme hatasƒ±:', error);
          // Sessizce ge√ß, kullanƒ±cƒ±yƒ± rahatsƒ±z etme
        }
      }, pollingInterval);
    };

    // Aktif chat varsa polling ba≈ülat
    if (activeChatId && activeChat) {
      startPolling();
    }

    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [activeChatId, isLoadingMessages, activeChat, fastPolling]);

  // Mesaj limiti countdown'u i√ßin interval
  useEffect(() => {
    if (!messageLimitInfo || messageLimitInfo.canSendMessage || messageLimitInfo.remainingSeconds <= 0) {
      return;
    }

    const interval = setInterval(() => {
      setMessageLimitInfo(prevLimit => {
        if (!prevLimit || prevLimit.remainingSeconds <= 0) {
          return prevLimit;
        }

        const newRemainingSeconds = prevLimit.remainingSeconds - 1;
        
        if (newRemainingSeconds <= 0) {
          // Limit doldu, yeniden kontrol et
          refreshMessageLimit();
          return prevLimit;
        }

        // Countdown mesajƒ±nƒ± g√ºncelle
        const minutes = Math.floor(newRemainingSeconds / 60);
        const seconds = newRemainingSeconds % 60;
        const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        return {
          ...prevLimit,
          remainingSeconds: newRemainingSeconds,
          message: `Sonraki mesaj: ${timeString}`
        };
      });
    }, 1000);

    return () => clearInterval(interval);
  }, [messageLimitInfo]);

  // Hata g√∂sterimi
  useEffect(() => {
    if (error) {
      Alert.alert('Hata', error, [
        { text: 'Tamam', onPress: clearError }
      ]);
    }
  }, [error]);

  return (
    <ChatContext.Provider
      value={{
        chatList,
        isLoadingChatList,
        refreshChatList,
        privateChatList,
        isLoadingPrivateChats,
        refreshPrivateChats,
        activeChat,
        activeChatId,
        isLoadingMessages,
        sendGlobalMessage,
        sendPrivateMessage,
        loadMessages,
        loadMoreMessages,
        messageLimitInfo,
        refreshMessageLimit,
        addNewMessage,
        markMessagesAsRead,
        isTyping,
        setIsTyping,
        setFastPolling,
        wsStatus,
        wsClient,
        joinChatRoom,
        leaveChatRoom,
        sendTypingIndicator,
        updateMessageStatus,
        typingUsers,
        error,
        clearError
      }}
    >
      {children}
    </ChatContext.Provider>
  );
}

// Context'i kullanmak i√ßin hook
export function useChat() {
  const context = useContext(ChatContext);
  if (context === undefined) {
    throw new Error('useChat must be used within a ChatProvider');
  }
  return context;
}
